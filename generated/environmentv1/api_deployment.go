/*
Dynatrace Environment API

Documentation of the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/xc03k3c).  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package environmentv1

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// DeploymentAPIService DeploymentAPI service
type DeploymentAPIService service

type ApiDownloadAgentInstallerWithVersionRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	osType string
	installerType string
	version string
	ifNoneMatch *string
	flavor *string
	arch *string
	bitness *string
	include *[]string
	skipMetadata *bool
	networkZone *string
}

// The ETag of the previous request. Do not download if it matches the ETag of the installer.
func (r ApiDownloadAgentInstallerWithVersionRequest) IfNoneMatch(ifNoneMatch string) ApiDownloadAgentInstallerWithVersionRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The flavor of your Linux distribution:   * &#x60;musl&#x60; for Linux distributions, which are using the musl C standard library, for example Alpine Linux.  * &#39;multidistro&#x60; for all Linux distributions which are using musl C and glibc standard library.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiDownloadAgentInstallerWithVersionRequest) Flavor(flavor string) ApiDownloadAgentInstallerWithVersionRequest {
	r.flavor = &flavor
	return r
}

// The architecture of your OS:   * &#x60;all&#x60;: Use this value for AIX and z/OS. Defaults to &#x60;x86&#x60; for other OS types.  * &#x60;x86&#x60;: x86 architecture. * &#x60;ppc&#x60;: PowerPC architecture, only supported for AIX and Linux. * &#x60;ppcle&#x60;: PowerPC Little Endian architecture, only supported for Linux. * &#x60;sparc&#x60;: Sparc architecture, only supported for Solaris.   * &#x60;arm&#x60;: ARM architecture, only supported for Linux.   * &#x60;s390&#x60;: S/390 architecture, only supported for Linux.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiDownloadAgentInstallerWithVersionRequest) Arch(arch string) ApiDownloadAgentInstallerWithVersionRequest {
	r.arch = &arch
	return r
}

// The bitness of your OS. Must be supported by the OS.    Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiDownloadAgentInstallerWithVersionRequest) Bitness(bitness string) ApiDownloadAgentInstallerWithVersionRequest {
	r.bitness = &bitness
	return r
}

// The code modules to be included to the installer. You can specify several modules in the following format: &#x60;include&#x3D;java&amp;include&#x3D;dotnet&#x60;.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiDownloadAgentInstallerWithVersionRequest) Include(include []string) ApiDownloadAgentInstallerWithVersionRequest {
	r.include = &include
	return r
}

// Set &#x60;true&#x60; to omit the OneAgent connectivity information from the installer.    Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiDownloadAgentInstallerWithVersionRequest) SkipMetadata(skipMetadata bool) ApiDownloadAgentInstallerWithVersionRequest {
	r.skipMetadata = &skipMetadata
	return r
}

// The network zone you want the result to be configured with.
func (r ApiDownloadAgentInstallerWithVersionRequest) NetworkZone(networkZone string) ApiDownloadAgentInstallerWithVersionRequest {
	r.networkZone = &networkZone
	return r
}

func (r ApiDownloadAgentInstallerWithVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadAgentInstallerWithVersionExecute(r)
}

/*
DownloadAgentInstallerWithVersion Downloads OneAgent installer of the specified version

For the `paas` or `paas-sh` installer types you can get a configuring installer, by passing additional parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param osType The operating system of the installer.
 @param installerType The type of the installer:   * `default`: Self-extracting installer for manual installation. Downloads an `.exe` file for Windows or an `.sh` file for Unix.  * `default-unattended`: Self-extracting installer for unattended installation. Windows only. Downloads a `.zip` archive, containing the `.msi` installer and the batch file. This option is deprecated with OneAgent version 1.173  * `mainframe`: Downloads all code modules for z/OS combined in a single `*.pax` archive.  * `paas`: Code modules installer. Downloads a `*.zip` archive, containing the `manifest.json` file with meta information or a `.jar` file for z/OS.  * `paas-sh`: Code modules installer. Downloads a self-extracting shell script with the embedded `tar.gz` archive.
 @param version The required version of the OneAgent in `1.155.275.20181112-084458` format.   You can retrieve the list of available versions with the [**GET available versions of OneAgent**](https://dt-url.net/fo23rb5) call.
 @return ApiDownloadAgentInstallerWithVersionRequest
*/
func (a *DeploymentAPIService) DownloadAgentInstallerWithVersion(ctx context.Context, osType string, installerType string, version string) ApiDownloadAgentInstallerWithVersionRequest {
	return ApiDownloadAgentInstallerWithVersionRequest{
		ApiService: a,
		ctx: ctx,
		osType: osType,
		installerType: installerType,
		version: version,
	}
}

// Execute executes the request
func (a *DeploymentAPIService) DownloadAgentInstallerWithVersionExecute(r ApiDownloadAgentInstallerWithVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.DownloadAgentInstallerWithVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/installer/agent/{osType}/{installerType}/version/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"osType"+"}", url.PathEscape(parameterValueToString(r.osType, "osType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"installerType"+"}", url.PathEscape(parameterValueToString(r.installerType, "installerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flavor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flavor", r.flavor, "")
	}
	if r.arch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arch", r.arch, "")
	}
	if r.bitness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bitness", r.bitness, "")
	}
	if r.include != nil {
		t := *r.include
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include", t, "multi")
		}
	}
	if r.skipMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipMetadata", r.skipMetadata, "")
	}
	if r.networkZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkZone", r.networkZone, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadAgentOrchestrationSignatureWithVersionRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	orchestrationType string
	version string
}

func (r ApiDownloadAgentOrchestrationSignatureWithVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadAgentOrchestrationSignatureWithVersionExecute(r)
}

/*
DownloadAgentOrchestrationSignatureWithVersion Downloads the requested version matching OneAgent deployment orchestration tarball's signature

Downloading the requested version matching deployment orchestration tarball's signature matching the requested Orchestration Type (ansible, puppet).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orchestrationType The Orchestration Type of the orchestration deployment script.
 @param version The requested version of the OneAgent deployment orchestration tarball in `0.1.0.20200925-120822` format.
 @return ApiDownloadAgentOrchestrationSignatureWithVersionRequest
*/
func (a *DeploymentAPIService) DownloadAgentOrchestrationSignatureWithVersion(ctx context.Context, orchestrationType string, version string) ApiDownloadAgentOrchestrationSignatureWithVersionRequest {
	return ApiDownloadAgentOrchestrationSignatureWithVersionRequest{
		ApiService: a,
		ctx: ctx,
		orchestrationType: orchestrationType,
		version: version,
	}
}

// Execute executes the request
func (a *DeploymentAPIService) DownloadAgentOrchestrationSignatureWithVersionExecute(r ApiDownloadAgentOrchestrationSignatureWithVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.DownloadAgentOrchestrationSignatureWithVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/orchestration/agent/{orchestrationType}/version/{version}/signature"
	localVarPath = strings.Replace(localVarPath, "{"+"orchestrationType"+"}", url.PathEscape(parameterValueToString(r.orchestrationType, "orchestrationType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadAgentOrchestrationWithVersionRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	orchestrationType string
	version string
}

func (r ApiDownloadAgentOrchestrationWithVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadAgentOrchestrationWithVersionExecute(r)
}

/*
DownloadAgentOrchestrationWithVersion Downloads the requested version matching OneAgent deployment orchestration tarball

Downloading the requested version matching deployment orchestration tarball matching the requested Orchestration Type (ansible, puppet).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orchestrationType The Orchestration Type of the orchestration deployment script.
 @param version The requested version of the OneAgent orchestration deployment tarball in `0.1.0.20200925-120822` format.
 @return ApiDownloadAgentOrchestrationWithVersionRequest
*/
func (a *DeploymentAPIService) DownloadAgentOrchestrationWithVersion(ctx context.Context, orchestrationType string, version string) ApiDownloadAgentOrchestrationWithVersionRequest {
	return ApiDownloadAgentOrchestrationWithVersionRequest{
		ApiService: a,
		ctx: ctx,
		orchestrationType: orchestrationType,
		version: version,
	}
}

// Execute executes the request
func (a *DeploymentAPIService) DownloadAgentOrchestrationWithVersionExecute(r ApiDownloadAgentOrchestrationWithVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.DownloadAgentOrchestrationWithVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/orchestration/agent/{orchestrationType}/version/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"orchestrationType"+"}", url.PathEscape(parameterValueToString(r.orchestrationType, "orchestrationType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadBoshReleaseWithVersionRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	osType string
	version string
	skipMetadata *bool
	networkZone *string
}

// Set &#x60;true&#x60; to omit the OneAgent connectivity information from the installer.    If not set, &#x60;false&#x60; is used.
func (r ApiDownloadBoshReleaseWithVersionRequest) SkipMetadata(skipMetadata bool) ApiDownloadBoshReleaseWithVersionRequest {
	r.skipMetadata = &skipMetadata
	return r
}

// The network zone you want the result to be configured with.
func (r ApiDownloadBoshReleaseWithVersionRequest) NetworkZone(networkZone string) ApiDownloadBoshReleaseWithVersionRequest {
	r.networkZone = &networkZone
	return r
}

func (r ApiDownloadBoshReleaseWithVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadBoshReleaseWithVersionExecute(r)
}

/*
DownloadBoshReleaseWithVersion Downloads BOSH release tarballs of the specified version, OneAgent included

For SaaS, the call is executed on an Environment ActiveGate. Be sure to use the base of an ActiveGate, **not** the environment.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param osType The operating system of the installer.
 @param version The required version of the OneAgent in the `1.155.275.20181112-084458` format.   You can retrieve the list of available versions with the [**GET available versions of BOSH tarballs**](https://dt-url.net/j703kdn) call.
 @return ApiDownloadBoshReleaseWithVersionRequest
*/
func (a *DeploymentAPIService) DownloadBoshReleaseWithVersion(ctx context.Context, osType string, version string) ApiDownloadBoshReleaseWithVersionRequest {
	return ApiDownloadBoshReleaseWithVersionRequest{
		ApiService: a,
		ctx: ctx,
		osType: osType,
		version: version,
	}
}

// Execute executes the request
func (a *DeploymentAPIService) DownloadBoshReleaseWithVersionExecute(r ApiDownloadBoshReleaseWithVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.DownloadBoshReleaseWithVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/boshrelease/agent/{osType}/version/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"osType"+"}", url.PathEscape(parameterValueToString(r.osType, "osType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skipMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipMetadata", r.skipMetadata, "")
	}
	if r.networkZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkZone", r.networkZone, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadGatewayInstallerWithVersionRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	osType string
	version string
	ifNoneMatch *string
	networkZone *string
	arch *string
}

// The ETag of the previous request. Do not download if it matches the ETag of the installer.
func (r ApiDownloadGatewayInstallerWithVersionRequest) IfNoneMatch(ifNoneMatch string) ApiDownloadGatewayInstallerWithVersionRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The network zone you want the result to be configured with. Requires at least ActiveGate version 1.247.
func (r ApiDownloadGatewayInstallerWithVersionRequest) NetworkZone(networkZone string) ApiDownloadGatewayInstallerWithVersionRequest {
	r.networkZone = &networkZone
	return r
}

// The architecture of your OS:   * &#x60;all&#x60;: Defaults to &#x60;amd64&#x60;.  * &#x60;amd64&#x60;: amd64 architecture. * &#x60;s390&#x60;: S/390 architecture, only supported for Linux.   
func (r ApiDownloadGatewayInstallerWithVersionRequest) Arch(arch string) ApiDownloadGatewayInstallerWithVersionRequest {
	r.arch = &arch
	return r
}

func (r ApiDownloadGatewayInstallerWithVersionRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadGatewayInstallerWithVersionExecute(r)
}

/*
DownloadGatewayInstallerWithVersion Downloads the ActiveGate installer of the specified version

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param osType The operating system of the installer.
 @param version The required version of the ActiveGate installer, in `1.155.275.20181112-084458` format.   You can retrieve the list of available versions with the [**GET available versions of ActiveGate**](https://dt-url.net/kh43rha) call.
 @return ApiDownloadGatewayInstallerWithVersionRequest
*/
func (a *DeploymentAPIService) DownloadGatewayInstallerWithVersion(ctx context.Context, osType string, version string) ApiDownloadGatewayInstallerWithVersionRequest {
	return ApiDownloadGatewayInstallerWithVersionRequest{
		ApiService: a,
		ctx: ctx,
		osType: osType,
		version: version,
	}
}

// Execute executes the request
func (a *DeploymentAPIService) DownloadGatewayInstallerWithVersionExecute(r ApiDownloadGatewayInstallerWithVersionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.DownloadGatewayInstallerWithVersion")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/installer/gateway/{osType}/version/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"osType"+"}", url.PathEscape(parameterValueToString(r.osType, "osType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.networkZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkZone", r.networkZone, "")
	}
	if r.arch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arch", r.arch, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadLatestAgentInstallerRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	osType string
	installerType string
	ifNoneMatch *string
	flavor *string
	arch *string
	bitness *string
	include *[]string
	skipMetadata *bool
	networkZone *string
}

// The ETag of the previous request. Do not download if it matches the ETag of the installer.
func (r ApiDownloadLatestAgentInstallerRequest) IfNoneMatch(ifNoneMatch string) ApiDownloadLatestAgentInstallerRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The flavor of your Linux distribution:   * &#x60;musl&#x60; for Linux distributions, which are using the musl C standard library, for example Alpine Linux.  * &#39;multidistro&#x60; for all Linux distributions which are using musl C and glibc standard library.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiDownloadLatestAgentInstallerRequest) Flavor(flavor string) ApiDownloadLatestAgentInstallerRequest {
	r.flavor = &flavor
	return r
}

// The architecture of your OS:   * &#x60;all&#x60;: Use this value for AIX and z/OS. Defaults to &#x60;x86&#x60; for other OS types.  * &#x60;x86&#x60;: x86 architecture. * &#x60;ppc&#x60;: PowerPC architecture, only supported for AIX and Linux. * &#x60;ppcle&#x60;: PowerPC Little Endian architecture, only supported for Linux. * &#x60;sparc&#x60;: Sparc architecture, only supported for Solaris.   * &#x60;arm&#x60;: ARM architecture, only supported for Linux.   * &#x60;s390&#x60;: S/390 architecture, only supported for Linux.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiDownloadLatestAgentInstallerRequest) Arch(arch string) ApiDownloadLatestAgentInstallerRequest {
	r.arch = &arch
	return r
}

// The bitness of your OS. Must be supported by the OS.    Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiDownloadLatestAgentInstallerRequest) Bitness(bitness string) ApiDownloadLatestAgentInstallerRequest {
	r.bitness = &bitness
	return r
}

// The code modules to be included to the installer. You can specify several modules in the following format: &#x60;include&#x3D;java&amp;include&#x3D;dotnet&#x60;.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiDownloadLatestAgentInstallerRequest) Include(include []string) ApiDownloadLatestAgentInstallerRequest {
	r.include = &include
	return r
}

// Set &#x60;true&#x60; to omit the OneAgent connectivity information from the installer.    Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiDownloadLatestAgentInstallerRequest) SkipMetadata(skipMetadata bool) ApiDownloadLatestAgentInstallerRequest {
	r.skipMetadata = &skipMetadata
	return r
}

// The network zone you want the result to be configured with.
func (r ApiDownloadLatestAgentInstallerRequest) NetworkZone(networkZone string) ApiDownloadLatestAgentInstallerRequest {
	r.networkZone = &networkZone
	return r
}

func (r ApiDownloadLatestAgentInstallerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadLatestAgentInstallerExecute(r)
}

/*
DownloadLatestAgentInstaller Downloads the latest OneAgent installer

For the `paas` or `paas-sh` installer types you can get a configuring installer, by passing additional parameters.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param osType The operating system of the installer.
 @param installerType The type of the installer:   * `default`: Self-extracting installer for manual installation. Downloads an `.exe` file for Windows or an `.sh` file for Unix.  * `default-unattended`: Self-extracting installer for unattended installation. Windows only. Downloads a `.zip` archive, containing the `.msi` installer and the batch file. This option is deprecated with OneAgent version 1.173  * `mainframe`: Downloads all code modules for z/OS combined in a single `*.pax` archive.  * `paas`: Code modules installer. Downloads a `*.zip` archive, containing the `manifest.json` file with meta information or a `.jar` file for z/OS.  * `paas-sh`: Code modules installer. Downloads a self-extracting shell script with the embedded `tar.gz` archive.
 @return ApiDownloadLatestAgentInstallerRequest
*/
func (a *DeploymentAPIService) DownloadLatestAgentInstaller(ctx context.Context, osType string, installerType string) ApiDownloadLatestAgentInstallerRequest {
	return ApiDownloadLatestAgentInstallerRequest{
		ApiService: a,
		ctx: ctx,
		osType: osType,
		installerType: installerType,
	}
}

// Execute executes the request
func (a *DeploymentAPIService) DownloadLatestAgentInstallerExecute(r ApiDownloadLatestAgentInstallerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.DownloadLatestAgentInstaller")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/installer/agent/{osType}/{installerType}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"osType"+"}", url.PathEscape(parameterValueToString(r.osType, "osType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"installerType"+"}", url.PathEscape(parameterValueToString(r.installerType, "installerType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flavor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flavor", r.flavor, "")
	}
	if r.arch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arch", r.arch, "")
	}
	if r.bitness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bitness", r.bitness, "")
	}
	if r.include != nil {
		t := *r.include
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include", t, "multi")
		}
	}
	if r.skipMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipMetadata", r.skipMetadata, "")
	}
	if r.networkZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkZone", r.networkZone, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadLatestAgentOrchestrationRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	orchestrationType string
}

func (r ApiDownloadLatestAgentOrchestrationRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadLatestAgentOrchestrationExecute(r)
}

/*
DownloadLatestAgentOrchestration Downloads the latest OneAgent deployment orchestration tarball

Downloading the latest available deployment orchestration script tarball matching the requested Orchestration Type (ansible, puppet).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orchestrationType The Orchestration Type of the orchestration deployment script.
 @return ApiDownloadLatestAgentOrchestrationRequest
*/
func (a *DeploymentAPIService) DownloadLatestAgentOrchestration(ctx context.Context, orchestrationType string) ApiDownloadLatestAgentOrchestrationRequest {
	return ApiDownloadLatestAgentOrchestrationRequest{
		ApiService: a,
		ctx: ctx,
		orchestrationType: orchestrationType,
	}
}

// Execute executes the request
func (a *DeploymentAPIService) DownloadLatestAgentOrchestrationExecute(r ApiDownloadLatestAgentOrchestrationRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.DownloadLatestAgentOrchestration")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/orchestration/agent/{orchestrationType}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"orchestrationType"+"}", url.PathEscape(parameterValueToString(r.orchestrationType, "orchestrationType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadLatestAgentOrchestrationSignatureRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	orchestrationType string
}

func (r ApiDownloadLatestAgentOrchestrationSignatureRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadLatestAgentOrchestrationSignatureExecute(r)
}

/*
DownloadLatestAgentOrchestrationSignature Downloads the latest OneAgent deployment orchestration tarball's signature

Downloading the latest available deployment orchestration tarball's sigature matching the requested Orchestration Type (ansible, puppet).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orchestrationType The Orchestration Type of the orchestration deployment script.
 @return ApiDownloadLatestAgentOrchestrationSignatureRequest
*/
func (a *DeploymentAPIService) DownloadLatestAgentOrchestrationSignature(ctx context.Context, orchestrationType string) ApiDownloadLatestAgentOrchestrationSignatureRequest {
	return ApiDownloadLatestAgentOrchestrationSignatureRequest{
		ApiService: a,
		ctx: ctx,
		orchestrationType: orchestrationType,
	}
}

// Execute executes the request
func (a *DeploymentAPIService) DownloadLatestAgentOrchestrationSignatureExecute(r ApiDownloadLatestAgentOrchestrationSignatureRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.DownloadLatestAgentOrchestrationSignature")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/orchestration/agent/{orchestrationType}/latest/signature"
	localVarPath = strings.Replace(localVarPath, "{"+"orchestrationType"+"}", url.PathEscape(parameterValueToString(r.orchestrationType, "orchestrationType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDownloadLatestGatewayInstallerRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	osType string
	ifNoneMatch *string
	networkZone *string
	arch *string
}

// The ETag of the previous request. Do not download if it matches the ETag of the installer.
func (r ApiDownloadLatestGatewayInstallerRequest) IfNoneMatch(ifNoneMatch string) ApiDownloadLatestGatewayInstallerRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The network zone you want the result to be configured with. Requires at least ActiveGate version 1.247.
func (r ApiDownloadLatestGatewayInstallerRequest) NetworkZone(networkZone string) ApiDownloadLatestGatewayInstallerRequest {
	r.networkZone = &networkZone
	return r
}

// The architecture of your OS:   * &#x60;all&#x60;: Defaults to &#x60;amd64&#x60;.  * &#x60;amd64&#x60;: amd64 architecture. * &#x60;s390&#x60;: S/390 architecture, only supported for Linux.   
func (r ApiDownloadLatestGatewayInstallerRequest) Arch(arch string) ApiDownloadLatestGatewayInstallerRequest {
	r.arch = &arch
	return r
}

func (r ApiDownloadLatestGatewayInstallerRequest) Execute() (*http.Response, error) {
	return r.ApiService.DownloadLatestGatewayInstallerExecute(r)
}

/*
DownloadLatestGatewayInstaller Downloads the configured standard ActiveGate installer of the latest version for the specified OS

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param osType The operating system of the installer.
 @return ApiDownloadLatestGatewayInstallerRequest
*/
func (a *DeploymentAPIService) DownloadLatestGatewayInstaller(ctx context.Context, osType string) ApiDownloadLatestGatewayInstallerRequest {
	return ApiDownloadLatestGatewayInstallerRequest{
		ApiService: a,
		ctx: ctx,
		osType: osType,
	}
}

// Execute executes the request
func (a *DeploymentAPIService) DownloadLatestGatewayInstallerExecute(r ApiDownloadLatestGatewayInstallerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.DownloadLatestGatewayInstaller")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/installer/gateway/{osType}/latest"
	localVarPath = strings.Replace(localVarPath, "{"+"osType"+"}", url.PathEscape(parameterValueToString(r.osType, "osType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.networkZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkZone", r.networkZone, "")
	}
	if r.arch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arch", r.arch, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetActiveGateInstallerAvailableVersionsRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	osType string
	arch *string
}

// The architecture of your OS:   * &#x60;all&#x60;: Defaults to &#x60;amd64&#x60;.  * &#x60;amd64&#x60;: amd64 architecture. * &#x60;s390&#x60;: S/390 architecture, only supported for Linux.   
func (r ApiGetActiveGateInstallerAvailableVersionsRequest) Arch(arch string) ApiGetActiveGateInstallerAvailableVersionsRequest {
	r.arch = &arch
	return r
}

func (r ApiGetActiveGateInstallerAvailableVersionsRequest) Execute() (*ActiveGateInstallerVersions, *http.Response, error) {
	return r.ApiService.GetActiveGateInstallerAvailableVersionsExecute(r)
}

/*
GetActiveGateInstallerAvailableVersions Lists all available versions of ActiveGate installer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param osType The operating system of the installer.
 @return ApiGetActiveGateInstallerAvailableVersionsRequest
*/
func (a *DeploymentAPIService) GetActiveGateInstallerAvailableVersions(ctx context.Context, osType string) ApiGetActiveGateInstallerAvailableVersionsRequest {
	return ApiGetActiveGateInstallerAvailableVersionsRequest{
		ApiService: a,
		ctx: ctx,
		osType: osType,
	}
}

// Execute executes the request
//  @return ActiveGateInstallerVersions
func (a *DeploymentAPIService) GetActiveGateInstallerAvailableVersionsExecute(r ApiGetActiveGateInstallerAvailableVersionsRequest) (*ActiveGateInstallerVersions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActiveGateInstallerVersions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetActiveGateInstallerAvailableVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/installer/gateway/versions/{osType}"
	localVarPath = strings.Replace(localVarPath, "{"+"osType"+"}", url.PathEscape(parameterValueToString(r.osType, "osType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.arch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arch", r.arch, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetActiveGateInstallerConnectionInfoRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	networkZone *string
}

// The network zone you want the result to be configured with.
func (r ApiGetActiveGateInstallerConnectionInfoRequest) NetworkZone(networkZone string) ApiGetActiveGateInstallerConnectionInfoRequest {
	r.networkZone = &networkZone
	return r
}

func (r ApiGetActiveGateInstallerConnectionInfoRequest) Execute() (*ActiveGateConnectionInfo, *http.Response, error) {
	return r.ApiService.GetActiveGateInstallerConnectionInfoExecute(r)
}

/*
GetActiveGateInstallerConnectionInfo Gets the connectivity information for Environment ActiveGate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetActiveGateInstallerConnectionInfoRequest
*/
func (a *DeploymentAPIService) GetActiveGateInstallerConnectionInfo(ctx context.Context) ApiGetActiveGateInstallerConnectionInfoRequest {
	return ApiGetActiveGateInstallerConnectionInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActiveGateConnectionInfo
func (a *DeploymentAPIService) GetActiveGateInstallerConnectionInfoExecute(r ApiGetActiveGateInstallerConnectionInfoRequest) (*ActiveGateConnectionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActiveGateConnectionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetActiveGateInstallerConnectionInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/installer/gateway/connectioninfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.networkZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkZone", r.networkZone, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAgentInstallerAvailableVersionsRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	osType string
	installerType string
	flavor *string
	arch *string
}

// The flavor of your Linux distribution:   * &#x60;musl&#x60; for Linux distributions, which are using the musl C standard library, for example Alpine Linux.  * &#39;multidistro&#x60; for all Linux distributions which are using musl C and glibc standard library.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiGetAgentInstallerAvailableVersionsRequest) Flavor(flavor string) ApiGetAgentInstallerAvailableVersionsRequest {
	r.flavor = &flavor
	return r
}

// The architecture of your OS:   * &#x60;all&#x60;: Use this value for AIX and z/OS. Defaults to &#x60;x86&#x60; for other OS types.  * &#x60;x86&#x60;: x86 architecture. * &#x60;ppc&#x60;: PowerPC architecture, only supported for AIX and Linux. * &#x60;ppcle&#x60;: PowerPC Little Endian architecture, only supported for Linux. * &#x60;sparc&#x60;: Sparc architecture, only supported for Solaris.   * &#x60;arm&#x60;: ARM architecture, only supported for Linux.   * &#x60;s390&#x60;: S/390 architecture, only supported for Linux.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiGetAgentInstallerAvailableVersionsRequest) Arch(arch string) ApiGetAgentInstallerAvailableVersionsRequest {
	r.arch = &arch
	return r
}

func (r ApiGetAgentInstallerAvailableVersionsRequest) Execute() (*AgentInstallerVersions, *http.Response, error) {
	return r.ApiService.GetAgentInstallerAvailableVersionsExecute(r)
}

/*
GetAgentInstallerAvailableVersions Lists all available versions of OneAgent installer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param osType The operating system of the installer.
 @param installerType The type of the installer:   * `default`: Self-extracting installer for manual installation. Downloads an `.exe` file for Windows or an `.sh` file for Unix.  * `default-unattended`: Self-extracting installer for unattended installation. Windows only. Downloads a `.zip` archive, containing the `.msi` installer and the batch file. This option is deprecated with OneAgent version 1.173  * `mainframe`: Downloads all code modules for z/OS combined in a single `*.pax` archive.  * `paas`: Code modules installer. Downloads a `*.zip` archive, containing the `manifest.json` file with meta information or a `.jar` file for z/OS.  * `paas-sh`: Code modules installer. Downloads a self-extracting shell script with the embedded `tar.gz` archive.
 @return ApiGetAgentInstallerAvailableVersionsRequest
*/
func (a *DeploymentAPIService) GetAgentInstallerAvailableVersions(ctx context.Context, osType string, installerType string) ApiGetAgentInstallerAvailableVersionsRequest {
	return ApiGetAgentInstallerAvailableVersionsRequest{
		ApiService: a,
		ctx: ctx,
		osType: osType,
		installerType: installerType,
	}
}

// Execute executes the request
//  @return AgentInstallerVersions
func (a *DeploymentAPIService) GetAgentInstallerAvailableVersionsExecute(r ApiGetAgentInstallerAvailableVersionsRequest) (*AgentInstallerVersions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AgentInstallerVersions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetAgentInstallerAvailableVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/installer/agent/versions/{osType}/{installerType}"
	localVarPath = strings.Replace(localVarPath, "{"+"osType"+"}", url.PathEscape(parameterValueToString(r.osType, "osType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"installerType"+"}", url.PathEscape(parameterValueToString(r.installerType, "installerType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flavor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flavor", r.flavor, "")
	}
	if r.arch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arch", r.arch, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAgentInstallerConnectionInfoRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	networkZone *string
	defaultZoneFallback *bool
	version *string
}

// The network zone you want the result to be configured with.
func (r ApiGetAgentInstallerConnectionInfoRequest) NetworkZone(networkZone string) ApiGetAgentInstallerConnectionInfoRequest {
	r.networkZone = &networkZone
	return r
}

// Set &#x60;true&#x60; to perform a fallback to the default network zone if the provided network zone does not exist.
func (r ApiGetAgentInstallerConnectionInfoRequest) DefaultZoneFallback(defaultZoneFallback bool) ApiGetAgentInstallerConnectionInfoRequest {
	r.defaultZoneFallback = &defaultZoneFallback
	return r
}

// The version of the OneAgent for which you&#39;re requesting connectivity information, in the &#x60;1.221&#x60; format.   Set this parameter to get the best format of endpoint list for optimal performance.
func (r ApiGetAgentInstallerConnectionInfoRequest) Version(version string) ApiGetAgentInstallerConnectionInfoRequest {
	r.version = &version
	return r
}

func (r ApiGetAgentInstallerConnectionInfoRequest) Execute() (*ConnectionInfo, *http.Response, error) {
	return r.ApiService.GetAgentInstallerConnectionInfoExecute(r)
}

/*
GetAgentInstallerConnectionInfo Gets the connectivity information for OneAgent

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAgentInstallerConnectionInfoRequest
*/
func (a *DeploymentAPIService) GetAgentInstallerConnectionInfo(ctx context.Context) ApiGetAgentInstallerConnectionInfoRequest {
	return ApiGetAgentInstallerConnectionInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ConnectionInfo
func (a *DeploymentAPIService) GetAgentInstallerConnectionInfoExecute(r ApiGetAgentInstallerConnectionInfoRequest) (*ConnectionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ConnectionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetAgentInstallerConnectionInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/installer/agent/connectioninfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.networkZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkZone", r.networkZone, "")
	}
	if r.defaultZoneFallback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultZoneFallback", r.defaultZoneFallback, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAgentInstallerConnectionInfoEndpointsRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	networkZone *string
	defaultZoneFallback *bool
}

func (r ApiGetAgentInstallerConnectionInfoEndpointsRequest) NetworkZone(networkZone string) ApiGetAgentInstallerConnectionInfoEndpointsRequest {
	r.networkZone = &networkZone
	return r
}

// Set &#x60;true&#x60; to perform a fallback to the default network zone if the provided network zone does not exist.
func (r ApiGetAgentInstallerConnectionInfoEndpointsRequest) DefaultZoneFallback(defaultZoneFallback bool) ApiGetAgentInstallerConnectionInfoEndpointsRequest {
	r.defaultZoneFallback = &defaultZoneFallback
	return r
}

func (r ApiGetAgentInstallerConnectionInfoEndpointsRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetAgentInstallerConnectionInfoEndpointsExecute(r)
}

/*
GetAgentInstallerConnectionInfoEndpoints Gets the list of the ActiveGate-Endpoints to be used for Agents ordered by networkzone-priorities.

Highest priority first, separated by a semicolon.If no network zone provided the default zone is used. Responds with 404 if network zone is not known.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAgentInstallerConnectionInfoEndpointsRequest
*/
func (a *DeploymentAPIService) GetAgentInstallerConnectionInfoEndpoints(ctx context.Context) ApiGetAgentInstallerConnectionInfoEndpointsRequest {
	return ApiGetAgentInstallerConnectionInfoEndpointsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *DeploymentAPIService) GetAgentInstallerConnectionInfoEndpointsExecute(r ApiGetAgentInstallerConnectionInfoEndpointsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetAgentInstallerConnectionInfoEndpoints")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/installer/agent/connectioninfo/endpoints"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.networkZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkZone", r.networkZone, "")
	}
	if r.defaultZoneFallback != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "defaultZoneFallback", r.defaultZoneFallback, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAgentInstallerMetaInfoRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	osType string
	installerType string
	flavor *string
	arch *string
	bitness *string
}

// The flavor of your Linux distribution:   * &#x60;musl&#x60; for Linux distributions, which are using the musl C standard library, for example Alpine Linux.  * &#39;multidistro&#x60; for all Linux distributions which are using musl C and glibc standard library.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiGetAgentInstallerMetaInfoRequest) Flavor(flavor string) ApiGetAgentInstallerMetaInfoRequest {
	r.flavor = &flavor
	return r
}

// The architecture of your OS:   * &#x60;all&#x60;: Use this value for AIX and z/OS. Defaults to &#x60;x86&#x60; for other OS types.  * &#x60;x86&#x60;: x86 architecture. * &#x60;ppc&#x60;: PowerPC architecture, only supported for AIX and Linux. * &#x60;ppcle&#x60;: PowerPC Little Endian architecture, only supported for Linux. * &#x60;sparc&#x60;: Sparc architecture, only supported for Solaris.   * &#x60;arm&#x60;: ARM architecture, only supported for Linux.   * &#x60;s390&#x60;: S/390 architecture, only supported for Linux.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiGetAgentInstallerMetaInfoRequest) Arch(arch string) ApiGetAgentInstallerMetaInfoRequest {
	r.arch = &arch
	return r
}

// The bitness of your OS. Must be supported by the OS.    Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiGetAgentInstallerMetaInfoRequest) Bitness(bitness string) ApiGetAgentInstallerMetaInfoRequest {
	r.bitness = &bitness
	return r
}

func (r ApiGetAgentInstallerMetaInfoRequest) Execute() (*InstallerMetaInfoDto, *http.Response, error) {
	return r.ApiService.GetAgentInstallerMetaInfoExecute(r)
}

/*
GetAgentInstallerMetaInfo Gets the latest available version of a OneAgent installer

If a [standard version](https://dt-url.net/ml03yye) is configured, then this is the downloaded version. 

Non-required parameters are only applicable to the `paas` and `paas-sh` installer types.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param osType The operating system of the installer.
 @param installerType The type of the installer:   * `default`: Self-extracting installer for manual installation. Downloads an `.exe` file for Windows or an `.sh` file for Unix.  * `default-unattended`: Self-extracting installer for unattended installation. Windows only. Downloads a `.zip` archive, containing the `.msi` installer and the batch file. This option is deprecated with OneAgent version 1.173  * `mainframe`: Downloads all code modules for z/OS combined in a single `*.pax` archive.  * `paas`: Code modules installer. Downloads a `*.zip` archive, containing the `manifest.json` file with meta information or a `.jar` file for z/OS.  * `paas-sh`: Code modules installer. Downloads a self-extracting shell script with the embedded `tar.gz` archive.
 @return ApiGetAgentInstallerMetaInfoRequest
*/
func (a *DeploymentAPIService) GetAgentInstallerMetaInfo(ctx context.Context, osType string, installerType string) ApiGetAgentInstallerMetaInfoRequest {
	return ApiGetAgentInstallerMetaInfoRequest{
		ApiService: a,
		ctx: ctx,
		osType: osType,
		installerType: installerType,
	}
}

// Execute executes the request
//  @return InstallerMetaInfoDto
func (a *DeploymentAPIService) GetAgentInstallerMetaInfoExecute(r ApiGetAgentInstallerMetaInfoRequest) (*InstallerMetaInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InstallerMetaInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetAgentInstallerMetaInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/installer/agent/{osType}/{installerType}/latest/metainfo"
	localVarPath = strings.Replace(localVarPath, "{"+"osType"+"}", url.PathEscape(parameterValueToString(r.osType, "osType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"installerType"+"}", url.PathEscape(parameterValueToString(r.installerType, "installerType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flavor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flavor", r.flavor, "")
	}
	if r.arch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arch", r.arch, "")
	}
	if r.bitness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bitness", r.bitness, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAgentInstallerWithVersionChecksumRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	osType string
	installerType string
	version string
	ifNoneMatch *string
	flavor *string
	arch *string
	bitness *string
	include *[]string
	networkZone *string
}

// The ETag of the previous request. Do not download if it matches the ETag of the installer.
func (r ApiGetAgentInstallerWithVersionChecksumRequest) IfNoneMatch(ifNoneMatch string) ApiGetAgentInstallerWithVersionChecksumRequest {
	r.ifNoneMatch = &ifNoneMatch
	return r
}

// The flavor of your Linux distribution:   * &#x60;musl&#x60; for Linux distributions, which are using the musl C standard library, for example Alpine Linux.  * &#39;multidistro&#x60; for all Linux distributions which are using musl C and glibc standard library.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiGetAgentInstallerWithVersionChecksumRequest) Flavor(flavor string) ApiGetAgentInstallerWithVersionChecksumRequest {
	r.flavor = &flavor
	return r
}

// The architecture of your OS:   * &#x60;all&#x60;: Use this value for AIX and z/OS. Defaults to &#x60;x86&#x60; for other OS types.  * &#x60;x86&#x60;: x86 architecture. * &#x60;ppc&#x60;: PowerPC architecture, only supported for AIX and Linux. * &#x60;ppcle&#x60;: PowerPC Little Endian architecture, only supported for Linux. * &#x60;sparc&#x60;: Sparc architecture, only supported for Solaris.   * &#x60;arm&#x60;: ARM architecture, only supported for Linux.   * &#x60;s390&#x60;: S/390 architecture, only supported for Linux.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiGetAgentInstallerWithVersionChecksumRequest) Arch(arch string) ApiGetAgentInstallerWithVersionChecksumRequest {
	r.arch = &arch
	return r
}

// The bitness of your OS. Must be supported by the OS.    Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiGetAgentInstallerWithVersionChecksumRequest) Bitness(bitness string) ApiGetAgentInstallerWithVersionChecksumRequest {
	r.bitness = &bitness
	return r
}

// The code modules to be included to the installer. You can specify several modules in the following format: &#x60;include&#x3D;java&amp;include&#x3D;dotnet&#x60;.   Only applicable to the &#x60;paas&#x60; and &#x60;paas-sh&#x60; installer types.
func (r ApiGetAgentInstallerWithVersionChecksumRequest) Include(include []string) ApiGetAgentInstallerWithVersionChecksumRequest {
	r.include = &include
	return r
}

// The network zone you want the result to be configured with.
func (r ApiGetAgentInstallerWithVersionChecksumRequest) NetworkZone(networkZone string) ApiGetAgentInstallerWithVersionChecksumRequest {
	r.networkZone = &networkZone
	return r
}

func (r ApiGetAgentInstallerWithVersionChecksumRequest) Execute() (*OneAgentInstallerChecksum, *http.Response, error) {
	return r.ApiService.GetAgentInstallerWithVersionChecksumExecute(r)
}

/*
GetAgentInstallerWithVersionChecksum Gets the checksum of a non-customized OneAgent installer

The checksum is the sha256 hash of the installer file.

Compare this checksum only with a non-customized OneAgent installer.

To get a non-customized installer, set the **skipMetadata** query parameter of the download endpoint to `true`.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param osType The operating system of the installer.
 @param installerType The type of the installer.
 @param version The required version of the OneAgent in `1.155.275.20181112-084458` format.   You can retrieve the list of available versions with the [**GET available versions of OneAgent**](https://dt-url.net/fo23rb5) call.
 @return ApiGetAgentInstallerWithVersionChecksumRequest
*/
func (a *DeploymentAPIService) GetAgentInstallerWithVersionChecksum(ctx context.Context, osType string, installerType string, version string) ApiGetAgentInstallerWithVersionChecksumRequest {
	return ApiGetAgentInstallerWithVersionChecksumRequest{
		ApiService: a,
		ctx: ctx,
		osType: osType,
		installerType: installerType,
		version: version,
	}
}

// Execute executes the request
//  @return OneAgentInstallerChecksum
func (a *DeploymentAPIService) GetAgentInstallerWithVersionChecksumExecute(r ApiGetAgentInstallerWithVersionChecksumRequest) (*OneAgentInstallerChecksum, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OneAgentInstallerChecksum
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetAgentInstallerWithVersionChecksum")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/installer/agent/{osType}/{installerType}/version/{version}/checksum"
	localVarPath = strings.Replace(localVarPath, "{"+"osType"+"}", url.PathEscape(parameterValueToString(r.osType, "osType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"installerType"+"}", url.PathEscape(parameterValueToString(r.installerType, "installerType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.flavor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "flavor", r.flavor, "")
	}
	if r.arch != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "arch", r.arch, "")
	}
	if r.bitness != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "bitness", r.bitness, "")
	}
	if r.include != nil {
		t := *r.include
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "include", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "include", t, "multi")
		}
	}
	if r.networkZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkZone", r.networkZone, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifNoneMatch != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "If-None-Match", r.ifNoneMatch, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAgentProcessModuleConfigRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	revision *int64
}

// The previously received revision to compare against.
func (r ApiGetAgentProcessModuleConfigRequest) Revision(revision int64) ApiGetAgentProcessModuleConfigRequest {
	r.revision = &revision
	return r
}

func (r ApiGetAgentProcessModuleConfigRequest) Execute() (*AgentProcessModuleConfigResponse, *http.Response, error) {
	return r.ApiService.GetAgentProcessModuleConfigExecute(r)
}

/*
GetAgentProcessModuleConfig Gets the latest process module config | maturity=EARLY_ADOPTER

Returns the latest process module config. Passing a previously gotten revision will first do a revision check, and return a 304 response if no changes were detected.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAgentProcessModuleConfigRequest
*/
func (a *DeploymentAPIService) GetAgentProcessModuleConfig(ctx context.Context) ApiGetAgentProcessModuleConfigRequest {
	return ApiGetAgentProcessModuleConfigRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AgentProcessModuleConfigResponse
func (a *DeploymentAPIService) GetAgentProcessModuleConfigExecute(r ApiGetAgentProcessModuleConfigRequest) (*AgentProcessModuleConfigResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AgentProcessModuleConfigResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetAgentProcessModuleConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/installer/agent/processmoduleconfig"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.revision != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "revision", r.revision, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBoshReleaseAvailableVersionsRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	osType string
}

func (r ApiGetBoshReleaseAvailableVersionsRequest) Execute() (*BoshReleaseAvailableVersions, *http.Response, error) {
	return r.ApiService.GetBoshReleaseAvailableVersionsExecute(r)
}

/*
GetBoshReleaseAvailableVersions Gets the list of available OneAgent versions for BOSH release tarballs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param osType The operating system of the installer.
 @return ApiGetBoshReleaseAvailableVersionsRequest
*/
func (a *DeploymentAPIService) GetBoshReleaseAvailableVersions(ctx context.Context, osType string) ApiGetBoshReleaseAvailableVersionsRequest {
	return ApiGetBoshReleaseAvailableVersionsRequest{
		ApiService: a,
		ctx: ctx,
		osType: osType,
	}
}

// Execute executes the request
//  @return BoshReleaseAvailableVersions
func (a *DeploymentAPIService) GetBoshReleaseAvailableVersionsExecute(r ApiGetBoshReleaseAvailableVersionsRequest) (*BoshReleaseAvailableVersions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BoshReleaseAvailableVersions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetBoshReleaseAvailableVersions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/boshrelease/versions/{osType}"
	localVarPath = strings.Replace(localVarPath, "{"+"osType"+"}", url.PathEscape(parameterValueToString(r.osType, "osType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBoshReleaseChecksumRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
	osType string
	version string
	skipMetadata *bool
	networkZone *string
}

// Set &#x60;true&#x60; to omit the OneAgent connectivity information from the installer.    If not set, &#x60;false&#x60; is used.
func (r ApiGetBoshReleaseChecksumRequest) SkipMetadata(skipMetadata bool) ApiGetBoshReleaseChecksumRequest {
	r.skipMetadata = &skipMetadata
	return r
}

// The network zone you want the result to be configured with.
func (r ApiGetBoshReleaseChecksumRequest) NetworkZone(networkZone string) ApiGetBoshReleaseChecksumRequest {
	r.networkZone = &networkZone
	return r
}

func (r ApiGetBoshReleaseChecksumRequest) Execute() (*BoshReleaseChecksum, *http.Response, error) {
	return r.ApiService.GetBoshReleaseChecksumExecute(r)
}

/*
GetBoshReleaseChecksum Gets the checksum of the specified BOSH release tarball

The checksum is the sha256 hash of the installer file. 

Result is not stable if **skipMetadata** is set to `false`.

For SaaS only works on environment ActiveGates version 1.176 or higher

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param osType The operating system of the installer.
 @param version The required version of the OneAgent in the `1.155.275.20181112-084458` format.   You can retrieve the list of available versions with the [**GET available versions of BOSH tarballs**](https://dt-url.net/j703kdn) call.
 @return ApiGetBoshReleaseChecksumRequest
*/
func (a *DeploymentAPIService) GetBoshReleaseChecksum(ctx context.Context, osType string, version string) ApiGetBoshReleaseChecksumRequest {
	return ApiGetBoshReleaseChecksumRequest{
		ApiService: a,
		ctx: ctx,
		osType: osType,
		version: version,
	}
}

// Execute executes the request
//  @return BoshReleaseChecksum
func (a *DeploymentAPIService) GetBoshReleaseChecksumExecute(r ApiGetBoshReleaseChecksumRequest) (*BoshReleaseChecksum, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BoshReleaseChecksum
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetBoshReleaseChecksum")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/boshrelease/agent/{osType}/version/{version}/checksum"
	localVarPath = strings.Replace(localVarPath, "{"+"osType"+"}", url.PathEscape(parameterValueToString(r.osType, "osType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", url.PathEscape(parameterValueToString(r.version, "version")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.skipMetadata != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "skipMetadata", r.skipMetadata, "")
	}
	if r.networkZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkZone", r.networkZone, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLatestLambdaBuildUnitsRequest struct {
	ctx context.Context
	ApiService *DeploymentAPIService
}

func (r ApiGetLatestLambdaBuildUnitsRequest) Execute() (*LatestLambdaLayerNames, *http.Response, error) {
	return r.ApiService.GetLatestLambdaBuildUnitsExecute(r)
}

/*
GetLatestLambdaBuildUnits Get the latest version names of the OneAgent for AWS Lambda

Get the latest version names of the OneAgent for the Java, Node.js, and Python AWS Lambda runtimes, also including names for layers that are combined with the log collector, as well as for the standalone log collector layer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLatestLambdaBuildUnitsRequest
*/
func (a *DeploymentAPIService) GetLatestLambdaBuildUnits(ctx context.Context) ApiGetLatestLambdaBuildUnitsRequest {
	return ApiGetLatestLambdaBuildUnitsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LatestLambdaLayerNames
func (a *DeploymentAPIService) GetLatestLambdaBuildUnitsExecute(r ApiGetLatestLambdaBuildUnitsRequest) (*LatestLambdaLayerNames, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LatestLambdaLayerNames
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DeploymentAPIService.GetLatestLambdaBuildUnits")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/deployment/lambda/agent/latest"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
