/*
Dynatrace Environment API

Documentation of the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/xc03k3c).  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package environmentv1

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// RUMUserSessionsAPIService RUMUserSessionsAPI service
type RUMUserSessionsAPIService service

type ApiGetUsqlResultAsTableRequest struct {
	ctx context.Context
	ApiService *RUMUserSessionsAPIService
	query *string
	startTimestamp *int64
	endTimestamp *int64
	offsetUTC *int32
	pageSize *int32
	pageOffset *int32
	addDeepLinkFields *bool
	explain *bool
}

// The user session query to be executed. See [USQL documentation page](https://dt-url.net/dtusql) for syntax details.    You can find the available columns of the **usersession** table in the &#x60;UserSession&#x60; object.    Here is an example of the query: &#x60;SELECT country, city, COUNT(*) FROM usersession GROUP BY country, city&#x60;.
func (r ApiGetUsqlResultAsTableRequest) Query(query string) ApiGetUsqlResultAsTableRequest {
	r.query = &query
	return r
}

// The start timestamp of the query, in UTC milliseconds.   If not set or set as &#x60;0&#x60;, 2 hours behind the current time is used.   If the exact times are important, set the timeframe in the query itself (**query** parameter).
func (r ApiGetUsqlResultAsTableRequest) StartTimestamp(startTimestamp int64) ApiGetUsqlResultAsTableRequest {
	r.startTimestamp = &startTimestamp
	return r
}

// The end timestamp of the query, in UTC milliseconds.   If not set or set as &#x60;0&#x60;, the current timestamp is used.   If the exact times are important, set the timeframe in the query itself (**query** parameter).
func (r ApiGetUsqlResultAsTableRequest) EndTimestamp(endTimestamp int64) ApiGetUsqlResultAsTableRequest {
	r.endTimestamp = &endTimestamp
	return r
}

// Optional offset of local time to UTC time in minutes. Offset will be applied to Date fields encountered in the query.   Can be positive or negative. E.g. if the local time is UTC+02:00, the timeOffset is 120. If it is UTC-05:00, timeOffset is -300.
func (r ApiGetUsqlResultAsTableRequest) OffsetUTC(offsetUTC int32) ApiGetUsqlResultAsTableRequest {
	r.offsetUTC = &offsetUTC
	return r
}

// Optional limit on how many of the actual query results should be returned in the tabular result.
func (r ApiGetUsqlResultAsTableRequest) PageSize(pageSize int32) ApiGetUsqlResultAsTableRequest {
	r.pageSize = &pageSize
	return r
}

// Optional offset of the requested results from the start of tabular results. Relates to pageSize.   E.g. on a query that might return 500 results, you might want to receive results in chunks of 50 rows.   this can be achieved by using pageSize&#x3D;50, and setting pageOffset in subsequent calls.In the example adding pageOffset&#x3D;50 returns result rows 51-100.
func (r ApiGetUsqlResultAsTableRequest) PageOffset(pageOffset int32) ApiGetUsqlResultAsTableRequest {
	r.pageOffset = &pageOffset
	return r
}

// Add (&#x60;true&#x60;) to enable deep linking of additional fields in the query.   If not set, then &#x60;false&#x60; is used
func (r ApiGetUsqlResultAsTableRequest) AddDeepLinkFields(addDeepLinkFields bool) ApiGetUsqlResultAsTableRequest {
	r.addDeepLinkFields = &addDeepLinkFields
	return r
}

// Add (&#x60;true&#x60;) or don&#39;t add (&#x60;false&#x60;) some additional information about the result to the response.   It helps to understand the query and how the result was calculated.   If not set, then &#x60;false&#x60; is used
func (r ApiGetUsqlResultAsTableRequest) Explain(explain bool) ApiGetUsqlResultAsTableRequest {
	r.explain = &explain
	return r
}

func (r ApiGetUsqlResultAsTableRequest) Execute() (*UsqlResultAsTable, *http.Response, error) {
	return r.ApiService.GetUsqlResultAsTableExecute(r)
}

/*
GetUsqlResultAsTable Returns the result of the query as a table structure

The result is a flat list of rows containing the requested columns.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsqlResultAsTableRequest
*/
func (a *RUMUserSessionsAPIService) GetUsqlResultAsTable(ctx context.Context) ApiGetUsqlResultAsTableRequest {
	return ApiGetUsqlResultAsTableRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsqlResultAsTable
func (a *RUMUserSessionsAPIService) GetUsqlResultAsTableExecute(r ApiGetUsqlResultAsTableRequest) (*UsqlResultAsTable, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsqlResultAsTable
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RUMUserSessionsAPIService.GetUsqlResultAsTable")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userSessionQueryLanguage/table"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	if r.startTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimestamp", r.startTimestamp, "")
	}
	if r.endTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimestamp", r.endTimestamp, "")
	}
	if r.offsetUTC != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetUTC", r.offsetUTC, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.pageOffset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageOffset", r.pageOffset, "")
	}
	if r.addDeepLinkFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addDeepLinkFields", r.addDeepLinkFields, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsqlResultAsTreeRequest struct {
	ctx context.Context
	ApiService *RUMUserSessionsAPIService
	query *string
	startTimestamp *int64
	endTimestamp *int64
	offsetUTC *int32
	addDeepLinkFields *bool
	explain *bool
}

// The user session query to be executed. See [USQL documentation page](https://dt-url.net/dtusql) for syntax details.    You can find the available columns of the **usersession** table in the &#x60;UserSession&#x60; object.    Here is an example of the query: &#x60;SELECT country, city, COUNT(*) FROM usersession GROUP BY country, city&#x60;.
func (r ApiGetUsqlResultAsTreeRequest) Query(query string) ApiGetUsqlResultAsTreeRequest {
	r.query = &query
	return r
}

// The start timestamp of the query, in UTC milliseconds.   If not set or set as &#x60;0&#x60;, 2 hours behind the current time is used.   If the exact times are important, set the timeframe in the query itself (**query** parameter).
func (r ApiGetUsqlResultAsTreeRequest) StartTimestamp(startTimestamp int64) ApiGetUsqlResultAsTreeRequest {
	r.startTimestamp = &startTimestamp
	return r
}

// The end timestamp of the query, in UTC milliseconds.   If not set or set as &#x60;0&#x60;, the current timestamp is used.   If the exact times are important, set the timeframe in the query itself (**query** parameter).
func (r ApiGetUsqlResultAsTreeRequest) EndTimestamp(endTimestamp int64) ApiGetUsqlResultAsTreeRequest {
	r.endTimestamp = &endTimestamp
	return r
}

// Optional offset of local time to UTC time in minutes. Offset will be applied to Date fields encountered in the query.   Can be positive or negative. E.g. if the local time is UTC+02:00, the timeOffset is 120. If it is UTC-05:00, timeOffset is -300.
func (r ApiGetUsqlResultAsTreeRequest) OffsetUTC(offsetUTC int32) ApiGetUsqlResultAsTreeRequest {
	r.offsetUTC = &offsetUTC
	return r
}

// Add (&#x60;true&#x60;) to enable deep linking of additional fields in the query.   If not set, then &#x60;false&#x60; is used
func (r ApiGetUsqlResultAsTreeRequest) AddDeepLinkFields(addDeepLinkFields bool) ApiGetUsqlResultAsTreeRequest {
	r.addDeepLinkFields = &addDeepLinkFields
	return r
}

// Add (&#x60;true&#x60;) or don&#39;t add (&#x60;false&#x60;) some additional information about the result to the response.   It helps to understand the query and how the result was calculated.   If not set, then &#x60;false&#x60; is used
func (r ApiGetUsqlResultAsTreeRequest) Explain(explain bool) ApiGetUsqlResultAsTreeRequest {
	r.explain = &explain
	return r
}

func (r ApiGetUsqlResultAsTreeRequest) Execute() (*UsqlResultAsTree, *http.Response, error) {
	return r.ApiService.GetUsqlResultAsTreeExecute(r)
}

/*
GetUsqlResultAsTree Returns the result of the query as a tree structure

To get a proper tree structure, you need to specify grouping in the query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsqlResultAsTreeRequest
*/
func (a *RUMUserSessionsAPIService) GetUsqlResultAsTree(ctx context.Context) ApiGetUsqlResultAsTreeRequest {
	return ApiGetUsqlResultAsTreeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsqlResultAsTree
func (a *RUMUserSessionsAPIService) GetUsqlResultAsTreeExecute(r ApiGetUsqlResultAsTreeRequest) (*UsqlResultAsTree, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsqlResultAsTree
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "RUMUserSessionsAPIService.GetUsqlResultAsTree")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/userSessionQueryLanguage/tree"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.query == nil {
		return localVarReturnValue, nil, reportError("query is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "query", r.query, "")
	if r.startTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimestamp", r.startTimestamp, "")
	}
	if r.endTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimestamp", r.endTimestamp, "")
	}
	if r.offsetUTC != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offsetUTC", r.offsetUTC, "")
	}
	if r.addDeepLinkFields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addDeepLinkFields", r.addDeepLinkFields, "")
	}
	if r.explain != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
