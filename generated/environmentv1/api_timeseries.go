/*
Dynatrace Environment API

Documentation of the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/xc03k3c).  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package environmentv1

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// TimeseriesAPIService TimeseriesAPI service
type TimeseriesAPIService service

type ApiCreateCustomTimeseriesRequest struct {
	ctx context.Context
	ApiService *TimeseriesAPIService
	timeseriesIdentifier string
	timeseriesRegistrationMessage *TimeseriesRegistrationMessage
}

// The JSON body of the request. Contains parameters of the new custom metric.
func (r ApiCreateCustomTimeseriesRequest) TimeseriesRegistrationMessage(timeseriesRegistrationMessage TimeseriesRegistrationMessage) ApiCreateCustomTimeseriesRequest {
	r.timeseriesRegistrationMessage = &timeseriesRegistrationMessage
	return r
}

func (r ApiCreateCustomTimeseriesRequest) Execute() (*TimeseriesDefinition, *http.Response, error) {
	return r.ApiService.CreateCustomTimeseriesExecute(r)
}

/*
CreateCustomTimeseries Creates a new custom metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timeseriesIdentifier The ID for the new metric. It must start with the `custom:` prefix.   You can use alphanumeric characters and the following punctuation marks: periods (`.`), hyphens (`-`), and commas (`,`). A number cannot follow a punctuation mark.   If you use the ID of an existing metric the respective parameters will be updated.   The length of ID is limited to **256 characters**.
 @return ApiCreateCustomTimeseriesRequest
*/
func (a *TimeseriesAPIService) CreateCustomTimeseries(ctx context.Context, timeseriesIdentifier string) ApiCreateCustomTimeseriesRequest {
	return ApiCreateCustomTimeseriesRequest{
		ApiService: a,
		ctx: ctx,
		timeseriesIdentifier: timeseriesIdentifier,
	}
}

// Execute executes the request
//  @return TimeseriesDefinition
func (a *TimeseriesAPIService) CreateCustomTimeseriesExecute(r ApiCreateCustomTimeseriesRequest) (*TimeseriesDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TimeseriesDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeseriesAPIService.CreateCustomTimeseries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/timeseries/{timeseriesIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"timeseriesIdentifier"+"}", url.PathEscape(parameterValueToString(r.timeseriesIdentifier, "timeseriesIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.timeseriesRegistrationMessage
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteCustomTimeseriesRequest struct {
	ctx context.Context
	ApiService *TimeseriesAPIService
	timeseriesIdentifier string
}

func (r ApiDeleteCustomTimeseriesRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCustomTimeseriesExecute(r)
}

/*
DeleteCustomTimeseries Deletes the specified custom metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timeseriesIdentifier The ID of the metric to delete.
 @return ApiDeleteCustomTimeseriesRequest
*/
func (a *TimeseriesAPIService) DeleteCustomTimeseries(ctx context.Context, timeseriesIdentifier string) ApiDeleteCustomTimeseriesRequest {
	return ApiDeleteCustomTimeseriesRequest{
		ApiService: a,
		ctx: ctx,
		timeseriesIdentifier: timeseriesIdentifier,
	}
}

// Execute executes the request
func (a *TimeseriesAPIService) DeleteCustomTimeseriesExecute(r ApiDeleteCustomTimeseriesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeseriesAPIService.DeleteCustomTimeseries")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/timeseries/{timeseriesIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"timeseriesIdentifier"+"}", url.PathEscape(parameterValueToString(r.timeseriesIdentifier, "timeseriesIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllTimeseriesDefinitionsRequest struct {
	ctx context.Context
	ApiService *TimeseriesAPIService
	source *string
	detailedSource *string
}

// The type of the metric, such as BUILTIN or CUSTOM.
func (r ApiGetAllTimeseriesDefinitionsRequest) Source(source string) ApiGetAllTimeseriesDefinitionsRequest {
	r.source = &source
	return r
}

// The feature where metrics originates, such as Synthetic or RUM.
func (r ApiGetAllTimeseriesDefinitionsRequest) DetailedSource(detailedSource string) ApiGetAllTimeseriesDefinitionsRequest {
	r.detailedSource = &detailedSource
	return r
}

func (r ApiGetAllTimeseriesDefinitionsRequest) Execute() ([]TimeseriesDefinition, *http.Response, error) {
	return r.ApiService.GetAllTimeseriesDefinitionsExecute(r)
}

/*
GetAllTimeseriesDefinitions Lists all metric definitions, with the parameters of each metric

You can specify filtering parameters to return only matched metrics. If no parameters are specified, the call will list all the defined metrics.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllTimeseriesDefinitionsRequest
*/
func (a *TimeseriesAPIService) GetAllTimeseriesDefinitions(ctx context.Context) ApiGetAllTimeseriesDefinitionsRequest {
	return ApiGetAllTimeseriesDefinitionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TimeseriesDefinition
func (a *TimeseriesAPIService) GetAllTimeseriesDefinitionsExecute(r ApiGetAllTimeseriesDefinitionsRequest) ([]TimeseriesDefinition, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TimeseriesDefinition
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeseriesAPIService.GetAllTimeseriesDefinitions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/timeseries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.source != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "source", r.source, "")
	}
	if r.detailedSource != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "detailedSource", r.detailedSource, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadTimeseriesComplexRequest struct {
	ctx context.Context
	ApiService *TimeseriesAPIService
	timeseriesIdentifier string
	timeseriesQueryMessage *TimeseriesQueryMessage
}

// The JSON body of the request, containing parameters to identify the required data points.
func (r ApiReadTimeseriesComplexRequest) TimeseriesQueryMessage(timeseriesQueryMessage TimeseriesQueryMessage) ApiReadTimeseriesComplexRequest {
	r.timeseriesQueryMessage = &timeseriesQueryMessage
	return r
}

func (r ApiReadTimeseriesComplexRequest) Execute() (*TimeseriesQueryResultWrapper, *http.Response, error) {
	return r.ApiService.ReadTimeseriesComplexExecute(r)
}

/*
ReadTimeseriesComplex Lists all available metric data points, matching the specified parameters

Provides advanced filtering possibilities, comparing to the `GET /timeseries/{metricIdentifier}` request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timeseriesIdentifier The case-sensitive ID of the timeseries from which you want to read parameters and data points.
 @return ApiReadTimeseriesComplexRequest
*/
func (a *TimeseriesAPIService) ReadTimeseriesComplex(ctx context.Context, timeseriesIdentifier string) ApiReadTimeseriesComplexRequest {
	return ApiReadTimeseriesComplexRequest{
		ApiService: a,
		ctx: ctx,
		timeseriesIdentifier: timeseriesIdentifier,
	}
}

// Execute executes the request
//  @return TimeseriesQueryResultWrapper
func (a *TimeseriesAPIService) ReadTimeseriesComplexExecute(r ApiReadTimeseriesComplexRequest) (*TimeseriesQueryResultWrapper, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TimeseriesQueryResultWrapper
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeseriesAPIService.ReadTimeseriesComplex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/timeseries/{timeseriesIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"timeseriesIdentifier"+"}", url.PathEscape(parameterValueToString(r.timeseriesIdentifier, "timeseriesIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.timeseriesQueryMessage
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReadTimeseriesDataRequest struct {
	ctx context.Context
	ApiService *TimeseriesAPIService
	timeseriesIdentifier string
	includeData *bool
	aggregationType *string
	startTimestamp *int64
	endTimestamp *int64
	predict *bool
	relativeTime *string
	queryMode *string
	entity *[]string
	tag *[]string
	percentile *int32
	includeParentIds *bool
	considerMaintenanceWindowsForAvailability *bool
}

// The flag to include data points in the response. Set to &#x60;true&#x60; to obtain data points. You must also specify the timeframe and aggregation type.   Defaults to &#x60;false&#x60;, meaning data points are not included.
func (r ApiReadTimeseriesDataRequest) IncludeData(includeData bool) ApiReadTimeseriesDataRequest {
	r.includeData = &includeData
	return r
}

// The aggregation type for the resulting data points.   If the requested metric doesn&#39;t support the specified aggregation, the request will result in an error.
func (r ApiReadTimeseriesDataRequest) AggregationType(aggregationType string) ApiReadTimeseriesDataRequest {
	r.aggregationType = &aggregationType
	return r
}

// The start timestamp of the requested timeframe, in UTC milliseconds.
func (r ApiReadTimeseriesDataRequest) StartTimestamp(startTimestamp int64) ApiReadTimeseriesDataRequest {
	r.startTimestamp = &startTimestamp
	return r
}

// The end timestamp of the requested timeframe, in milliseconds (UTC).   If later than the current time, Dynatrace automatically uses the current time instead.   The timeframe must not exceed 6 months.
func (r ApiReadTimeseriesDataRequest) EndTimestamp(endTimestamp int64) ApiReadTimeseriesDataRequest {
	r.endTimestamp = &endTimestamp
	return r
}

// The flag to predict future data points.
func (r ApiReadTimeseriesDataRequest) Predict(predict bool) ApiReadTimeseriesDataRequest {
	r.predict = &predict
	return r
}

// The relative timeframe, back from the current time.
func (r ApiReadTimeseriesDataRequest) RelativeTime(relativeTime string) ApiReadTimeseriesDataRequest {
	r.relativeTime = &relativeTime
	return r
}

// The type of result that the call should return. Valid result modes are:   &#x60;series&#x60;: returns all the data points of the timeseries in specified timeframe.  &#x60;total&#x60;: returns one scalar value for the specified timeframe.   By default, the &#x60;series&#x60; mode is used.
func (r ApiReadTimeseriesDataRequest) QueryMode(queryMode string) ApiReadTimeseriesDataRequest {
	r.queryMode = &queryMode
	return r
}

// Filters requested data points by the entity that should deliver them. Allowed values are Dynatrace entity IDs.   You can specify several entities in the following format: &#x60;entity&#x3D;entity1&amp;entity&#x3D;entity2&#x60;. The entity has to match at least one of the specified IDs.   If the selected entity doesn&#39;t support the requested timeseries, the request will result in an error.
func (r ApiReadTimeseriesDataRequest) Entity(entity []string) ApiReadTimeseriesDataRequest {
	r.entity = &entity
	return r
}

// Filters requested data points by entity which should deliver them. Only data from entities with the specified tag is delivered.   You can specify several tags in the following format: &#x60;tag&#x3D;tag1&amp;tag&#x3D;tag2&#x60;. The entity has to match **all** the specified tags.   In case of key-value tags, such as imported AWS or CloudFoundry tags use the &#x60;key:value&#x60; format. If there&#39;s also a context, use the &#x60;[context]key:value&#x60; format.
func (r ApiReadTimeseriesDataRequest) Tag(tag []string) ApiReadTimeseriesDataRequest {
	r.tag = &tag
	return r
}

// Specifies which percentile of the selected response time metric should be delivered.  Applicable only to the &#x60;PERCENTILE&#x60; aggregation type.   Valid values for percentile are between 1 and 99.   Keep in mind that percentile export is possible only for response-time-based metrics such as application and service response times.
func (r ApiReadTimeseriesDataRequest) Percentile(percentile int32) ApiReadTimeseriesDataRequest {
	r.percentile = &percentile
	return r
}

// If set to true the result exposes dimension mappings between parent entities and their children.  For instance: SERVICE-0000000000000001, SERVICE_METHOD-0000000000000001
func (r ApiReadTimeseriesDataRequest) IncludeParentIds(includeParentIds bool) ApiReadTimeseriesDataRequest {
	r.includeParentIds = &includeParentIds
	return r
}

// Exclude (&#x60;true&#x60;) or include (&#x60;false&#x60;) data points from any [maintenance window](https://dt-url.net/b2123rg0), defined in your environment.
func (r ApiReadTimeseriesDataRequest) ConsiderMaintenanceWindowsForAvailability(considerMaintenanceWindowsForAvailability bool) ApiReadTimeseriesDataRequest {
	r.considerMaintenanceWindowsForAvailability = &considerMaintenanceWindowsForAvailability
	return r
}

func (r ApiReadTimeseriesDataRequest) Execute() (*TimeseriesQueryResult, *http.Response, error) {
	return r.ApiService.ReadTimeseriesDataExecute(r)
}

/*
ReadTimeseriesData Gets the parameters of the specified metric and, optionally, its data points

To obtain data points, set **includeData** to `true`. 

You can obtain either data points or the scalar result of the specified timeseries, depending on the **queryMode**. 

To obtain data points, you must specify the timeframe, either as **relativeTime** or as a combination of **startTimestamp** and **endTimestamp**. 

You must also provide the **aggregationType**, supported by the metric.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timeseriesIdentifier The case-sensitive ID of the timeseries, from which you want to read parameters and data points.
 @return ApiReadTimeseriesDataRequest
*/
func (a *TimeseriesAPIService) ReadTimeseriesData(ctx context.Context, timeseriesIdentifier string) ApiReadTimeseriesDataRequest {
	return ApiReadTimeseriesDataRequest{
		ApiService: a,
		ctx: ctx,
		timeseriesIdentifier: timeseriesIdentifier,
	}
}

// Execute executes the request
//  @return TimeseriesQueryResult
func (a *TimeseriesAPIService) ReadTimeseriesDataExecute(r ApiReadTimeseriesDataRequest) (*TimeseriesQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TimeseriesQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TimeseriesAPIService.ReadTimeseriesData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/timeseries/{timeseriesIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"timeseriesIdentifier"+"}", url.PathEscape(parameterValueToString(r.timeseriesIdentifier, "timeseriesIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.includeData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeData", r.includeData, "")
	}
	if r.aggregationType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "aggregationType", r.aggregationType, "")
	}
	if r.startTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimestamp", r.startTimestamp, "")
	}
	if r.endTimestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endTimestamp", r.endTimestamp, "")
	}
	if r.predict != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "predict", r.predict, "")
	}
	if r.relativeTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "relativeTime", r.relativeTime, "")
	}
	if r.queryMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "queryMode", r.queryMode, "")
	}
	if r.entity != nil {
		t := *r.entity
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "entity", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "entity", t, "multi")
		}
	}
	if r.tag != nil {
		t := *r.tag
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tag", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tag", t, "multi")
		}
	}
	if r.percentile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentile", r.percentile, "")
	}
	if r.includeParentIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "includeParentIds", r.includeParentIds, "")
	}
	if r.considerMaintenanceWindowsForAvailability != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "considerMaintenanceWindowsForAvailability", r.considerMaintenanceWindowsForAvailability, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
