/*
Dynatrace Account Management API

The enterprise management API for Dynatrace SaaS enables automation of operational tasks related to user access and environment lifecycle management.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package account

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// PolicyManagementAPIService PolicyManagementAPI service
type PolicyManagementAPIService service

type ApiPolicyControllerAppendLevelPolicyBindingsRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	policyUuid string
	appendLevelPolicyBindingsRequestDto *AppendLevelPolicyBindingsRequestDto
}

// The JSON body of the request. Contains user groups that must use the policy.
func (r ApiPolicyControllerAppendLevelPolicyBindingsRequest) AppendLevelPolicyBindingsRequestDto(appendLevelPolicyBindingsRequestDto AppendLevelPolicyBindingsRequestDto) ApiPolicyControllerAppendLevelPolicyBindingsRequest {
	r.appendLevelPolicyBindingsRequestDto = &appendLevelPolicyBindingsRequestDto
	return r
}

func (r ApiPolicyControllerAppendLevelPolicyBindingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PolicyControllerAppendLevelPolicyBindingsExecute(r)
}

/*
PolicyControllerAppendLevelPolicyBindings Adds policy bindings to a level

Existing bindings remain unaffected.
This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param policyUuid The ID of the required policy.
 @return ApiPolicyControllerAppendLevelPolicyBindingsRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerAppendLevelPolicyBindings(ctx context.Context, levelType string, levelId string, policyUuid string) ApiPolicyControllerAppendLevelPolicyBindingsRequest {
	return ApiPolicyControllerAppendLevelPolicyBindingsRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) PolicyControllerAppendLevelPolicyBindingsExecute(r ApiPolicyControllerAppendLevelPolicyBindingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerAppendLevelPolicyBindings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appendLevelPolicyBindingsRequestDto == nil {
		return nil, reportError("appendLevelPolicyBindingsRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appendLevelPolicyBindingsRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPolicyControllerAppendParticularGroupBindingRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	policyUuid string
	groupUuid string
	appendLevelPolicyBindingForGroupDto *AppendLevelPolicyBindingForGroupDto
}

// The JSON body of the request. Contains parameters and metadata
func (r ApiPolicyControllerAppendParticularGroupBindingRequest) AppendLevelPolicyBindingForGroupDto(appendLevelPolicyBindingForGroupDto AppendLevelPolicyBindingForGroupDto) ApiPolicyControllerAppendParticularGroupBindingRequest {
	r.appendLevelPolicyBindingForGroupDto = &appendLevelPolicyBindingForGroupDto
	return r
}

func (r ApiPolicyControllerAppendParticularGroupBindingRequest) Execute() (*http.Response, error) {
	return r.ApiService.PolicyControllerAppendParticularGroupBindingExecute(r)
}

/*
PolicyControllerAppendParticularGroupBinding Append policy bindings within a level for a user group

This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param policyUuid The ID of the required policy.
 @param groupUuid The ID of the required user group.
 @return ApiPolicyControllerAppendParticularGroupBindingRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerAppendParticularGroupBinding(ctx context.Context, levelType string, levelId string, policyUuid string, groupUuid string) ApiPolicyControllerAppendParticularGroupBindingRequest {
	return ApiPolicyControllerAppendParticularGroupBindingRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		policyUuid: policyUuid,
		groupUuid: groupUuid,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) PolicyControllerAppendParticularGroupBindingExecute(r ApiPolicyControllerAppendParticularGroupBindingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerAppendParticularGroupBinding")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}/{groupUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupUuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appendLevelPolicyBindingForGroupDto == nil {
		return nil, reportError("appendLevelPolicyBindingForGroupDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appendLevelPolicyBindingForGroupDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPolicyControllerCreateLevelPolicyRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	createOrUpdateLevelPolicyRequestDto *CreateOrUpdateLevelPolicyRequestDto
}

// The JSON body of the request. Contains the configuration of a new policy.
func (r ApiPolicyControllerCreateLevelPolicyRequest) CreateOrUpdateLevelPolicyRequestDto(createOrUpdateLevelPolicyRequestDto CreateOrUpdateLevelPolicyRequestDto) ApiPolicyControllerCreateLevelPolicyRequest {
	r.createOrUpdateLevelPolicyRequestDto = &createOrUpdateLevelPolicyRequestDto
	return r
}

func (r ApiPolicyControllerCreateLevelPolicyRequest) Execute() (*LevelPolicyDto, *http.Response, error) {
	return r.ApiService.PolicyControllerCreateLevelPolicyExecute(r)
}

/*
PolicyControllerCreateLevelPolicy Creates a new policy

This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
 @return ApiPolicyControllerCreateLevelPolicyRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerCreateLevelPolicy(ctx context.Context, levelType string, levelId string) ApiPolicyControllerCreateLevelPolicyRequest {
	return ApiPolicyControllerCreateLevelPolicyRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
	}
}

// Execute executes the request
//  @return LevelPolicyDto
func (a *PolicyManagementAPIService) PolicyControllerCreateLevelPolicyExecute(r ApiPolicyControllerCreateLevelPolicyRequest) (*LevelPolicyDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LevelPolicyDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerCreateLevelPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrUpdateLevelPolicyRequestDto == nil {
		return localVarReturnValue, nil, reportError("createOrUpdateLevelPolicyRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrUpdateLevelPolicyRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPolicyControllerDeleteLevelPolicyRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	policyUuid string
	force bool
}

func (r ApiPolicyControllerDeleteLevelPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PolicyControllerDeleteLevelPolicyExecute(r)
}

/*
PolicyControllerDeleteLevelPolicy Deletes a policy

This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param policyUuid The ID of the required policy.
 @param force Set to `true` to delete a policy that is still in use.
 @return ApiPolicyControllerDeleteLevelPolicyRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerDeleteLevelPolicy(ctx context.Context, levelType string, levelId string, policyUuid string, force bool) ApiPolicyControllerDeleteLevelPolicyRequest {
	return ApiPolicyControllerDeleteLevelPolicyRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		policyUuid: policyUuid,
		force: force,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) PolicyControllerDeleteLevelPolicyExecute(r ApiPolicyControllerDeleteLevelPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerDeleteLevelPolicy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"force"+"}", url.PathEscape(parameterValueToString(r.force, "force")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPolicyControllerDeleteLevelPolicyBindingsRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
}

func (r ApiPolicyControllerDeleteLevelPolicyBindingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PolicyControllerDeleteLevelPolicyBindingsExecute(r)
}

/*
PolicyControllerDeleteLevelPolicyBindings Deletes all policy bindings from a level

This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @return ApiPolicyControllerDeleteLevelPolicyBindingsRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerDeleteLevelPolicyBindings(ctx context.Context, levelType string, levelId string) ApiPolicyControllerDeleteLevelPolicyBindingsRequest {
	return ApiPolicyControllerDeleteLevelPolicyBindingsRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) PolicyControllerDeleteLevelPolicyBindingsExecute(r ApiPolicyControllerDeleteLevelPolicyBindingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerDeleteLevelPolicyBindings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	policyUuid string
	forceMultiple *bool
}

// Forces multiple in case delete by parameters and metadata query
func (r ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyRequest) ForceMultiple(forceMultiple bool) ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyRequest {
	r.forceMultiple = &forceMultiple
	return r
}

func (r ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PolicyControllerDeleteLevelPolicyBindingsForPolicyExecute(r)
}

/*
PolicyControllerDeleteLevelPolicyBindingsForPolicy Deletes all bindings of a policy

This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param policyUuid The ID of the required policy.
 @return ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerDeleteLevelPolicyBindingsForPolicy(ctx context.Context, levelType string, levelId string, policyUuid string) ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyRequest {
	return ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) PolicyControllerDeleteLevelPolicyBindingsForPolicyExecute(r ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerDeleteLevelPolicyBindingsForPolicy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.forceMultiple == nil {
		return nil, reportError("forceMultiple is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "forceMultiple", r.forceMultiple, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyAndGroupRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	policyUuid string
	groupUuid string
	forceMultiple bool
}

func (r ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyAndGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.PolicyControllerDeleteLevelPolicyBindingsForPolicyAndGroupExecute(r)
}

/*
PolicyControllerDeleteLevelPolicyBindingsForPolicyAndGroup Deletes a policy binding from a user group

This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param policyUuid The ID of the required policy.
 @param groupUuid The ID of the required user group.
 @param forceMultiple Forces multiple in case delete by parameters and metadata query
 @return ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyAndGroupRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerDeleteLevelPolicyBindingsForPolicyAndGroup(ctx context.Context, levelType string, levelId string, policyUuid string, groupUuid string, forceMultiple bool) ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyAndGroupRequest {
	return ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyAndGroupRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		policyUuid: policyUuid,
		groupUuid: groupUuid,
		forceMultiple: forceMultiple,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) PolicyControllerDeleteLevelPolicyBindingsForPolicyAndGroupExecute(r ApiPolicyControllerDeleteLevelPolicyBindingsForPolicyAndGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerDeleteLevelPolicyBindingsForPolicyAndGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}/{groupUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupUuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"forceMultiple"+"}", url.PathEscape(parameterValueToString(r.forceMultiple, "forceMultiple")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPolicyControllerGetAllLevelPoliciesBindingsRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
}

func (r ApiPolicyControllerGetAllLevelPoliciesBindingsRequest) Execute() (*LevelPolicyBindingDto, *http.Response, error) {
	return r.ApiService.PolicyControllerGetAllLevelPoliciesBindingsExecute(r)
}

/*
PolicyControllerGetAllLevelPoliciesBindings Lists all policy bindings of a level

A policy binding shows which user groups use the policy.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @return ApiPolicyControllerGetAllLevelPoliciesBindingsRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerGetAllLevelPoliciesBindings(ctx context.Context, levelType string, levelId string) ApiPolicyControllerGetAllLevelPoliciesBindingsRequest {
	return ApiPolicyControllerGetAllLevelPoliciesBindingsRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
	}
}

// Execute executes the request
//  @return LevelPolicyBindingDto
func (a *PolicyManagementAPIService) PolicyControllerGetAllLevelPoliciesBindingsExecute(r ApiPolicyControllerGetAllLevelPoliciesBindingsRequest) (*LevelPolicyBindingDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LevelPolicyBindingDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerGetAllLevelPoliciesBindings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPolicyControllerGetEffectivePermissionsRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	entityType *string
	entityId *string
	explain *bool
	services *[]string
	page *float32
	size *float32
}

// Required entity type. The following values are available:   * user  * group
func (r ApiPolicyControllerGetEffectivePermissionsRequest) EntityType(entityType string) ApiPolicyControllerGetEffectivePermissionsRequest {
	r.entityType = &entityType
	return r
}

// Required entity id.
func (r ApiPolicyControllerGetEffectivePermissionsRequest) EntityId(entityId string) ApiPolicyControllerGetEffectivePermissionsRequest {
	r.entityId = &entityId
	return r
}

func (r ApiPolicyControllerGetEffectivePermissionsRequest) Explain(explain bool) ApiPolicyControllerGetEffectivePermissionsRequest {
	r.explain = &explain
	return r
}

// Optional services list. Policies for given services will be returned
func (r ApiPolicyControllerGetEffectivePermissionsRequest) Services(services []string) ApiPolicyControllerGetEffectivePermissionsRequest {
	r.services = &services
	return r
}

func (r ApiPolicyControllerGetEffectivePermissionsRequest) Page(page float32) ApiPolicyControllerGetEffectivePermissionsRequest {
	r.page = &page
	return r
}

func (r ApiPolicyControllerGetEffectivePermissionsRequest) Size(size float32) ApiPolicyControllerGetEffectivePermissionsRequest {
	r.size = &size
	return r
}

func (r ApiPolicyControllerGetEffectivePermissionsRequest) Execute() (*EffectivePermissions, *http.Response, error) {
	return r.ApiService.PolicyControllerGetEffectivePermissionsExecute(r)
}

/*
PolicyControllerGetEffectivePermissions Gets effective permissions for a user or group | maturity=EARLY_ADOPTER

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
 @return ApiPolicyControllerGetEffectivePermissionsRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerGetEffectivePermissions(ctx context.Context, levelType string, levelId string) ApiPolicyControllerGetEffectivePermissionsRequest {
	return ApiPolicyControllerGetEffectivePermissionsRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
	}
}

// Execute executes the request
//  @return EffectivePermissions
func (a *PolicyManagementAPIService) PolicyControllerGetEffectivePermissionsExecute(r ApiPolicyControllerGetEffectivePermissionsRequest) (*EffectivePermissions, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EffectivePermissions
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerGetEffectivePermissions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/resolution/{levelType}/{levelId}/effectivepermissions"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.entityType == nil {
		return localVarReturnValue, nil, reportError("entityType is required and must be specified")
	}
	if r.entityId == nil {
		return localVarReturnValue, nil, reportError("entityId is required and must be specified")
	}
	if r.explain == nil {
		return localVarReturnValue, nil, reportError("explain is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "entityType", r.entityType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "entityId", r.entityId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "explain", r.explain, "")
	if r.services != nil {
		t := *r.services
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "services;", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "services;", t, "multi")
		}
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPolicyControllerGetLevelDescendantsPolicyBindingsRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	policyUuid string
	page *float32
	size *float32
}

func (r ApiPolicyControllerGetLevelDescendantsPolicyBindingsRequest) Page(page float32) ApiPolicyControllerGetLevelDescendantsPolicyBindingsRequest {
	r.page = &page
	return r
}

func (r ApiPolicyControllerGetLevelDescendantsPolicyBindingsRequest) Size(size float32) ApiPolicyControllerGetLevelDescendantsPolicyBindingsRequest {
	r.size = &size
	return r
}

func (r ApiPolicyControllerGetLevelDescendantsPolicyBindingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PolicyControllerGetLevelDescendantsPolicyBindingsExecute(r)
}

/*
PolicyControllerGetLevelDescendantsPolicyBindings Get policy bindings within descendants of a level

This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.   Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param policyUuid The ID of the required policy.
 @return ApiPolicyControllerGetLevelDescendantsPolicyBindingsRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerGetLevelDescendantsPolicyBindings(ctx context.Context, levelType string, levelId string, policyUuid string) ApiPolicyControllerGetLevelDescendantsPolicyBindingsRequest {
	return ApiPolicyControllerGetLevelDescendantsPolicyBindingsRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) PolicyControllerGetLevelDescendantsPolicyBindingsExecute(r ApiPolicyControllerGetLevelDescendantsPolicyBindingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerGetLevelDescendantsPolicyBindings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/descendants/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPolicyControllerGetLevelPoliciesRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	name *string
}

// Optional policy name. Only policies that are of equal name will be returned.
func (r ApiPolicyControllerGetLevelPoliciesRequest) Name(name string) ApiPolicyControllerGetLevelPoliciesRequest {
	r.name = &name
	return r
}

func (r ApiPolicyControllerGetLevelPoliciesRequest) Execute() (*PolicyDtoList, *http.Response, error) {
	return r.ApiService.PolicyControllerGetLevelPoliciesExecute(r)
}

/*
PolicyControllerGetLevelPolicies Lists all native policies of a level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @return ApiPolicyControllerGetLevelPoliciesRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerGetLevelPolicies(ctx context.Context, levelType string, levelId string) ApiPolicyControllerGetLevelPoliciesRequest {
	return ApiPolicyControllerGetLevelPoliciesRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
	}
}

// Execute executes the request
//  @return PolicyDtoList
func (a *PolicyManagementAPIService) PolicyControllerGetLevelPoliciesExecute(r ApiPolicyControllerGetLevelPoliciesRequest) (*PolicyDtoList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyDtoList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerGetLevelPolicies")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPolicyControllerGetLevelPolicyRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	policyUuid string
}

func (r ApiPolicyControllerGetLevelPolicyRequest) Execute() (*LevelPolicyDto, *http.Response, error) {
	return r.ApiService.PolicyControllerGetLevelPolicyExecute(r)
}

/*
PolicyControllerGetLevelPolicy Gets a policy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param policyUuid The ID of the required policy.
 @return ApiPolicyControllerGetLevelPolicyRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerGetLevelPolicy(ctx context.Context, levelType string, levelId string, policyUuid string) ApiPolicyControllerGetLevelPolicyRequest {
	return ApiPolicyControllerGetLevelPolicyRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return LevelPolicyDto
func (a *PolicyManagementAPIService) PolicyControllerGetLevelPolicyExecute(r ApiPolicyControllerGetLevelPolicyRequest) (*LevelPolicyDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LevelPolicyDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerGetLevelPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPolicyControllerGetLevelPolicyBindingsRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	policyUuid string
}

func (r ApiPolicyControllerGetLevelPolicyBindingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PolicyControllerGetLevelPolicyBindingsExecute(r)
}

/*
PolicyControllerGetLevelPolicyBindings Get policy bindings within a level

This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param policyUuid The ID of the required policy.
 @return ApiPolicyControllerGetLevelPolicyBindingsRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerGetLevelPolicyBindings(ctx context.Context, levelType string, levelId string, policyUuid string) ApiPolicyControllerGetLevelPolicyBindingsRequest {
	return ApiPolicyControllerGetLevelPolicyBindingsRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) PolicyControllerGetLevelPolicyBindingsExecute(r ApiPolicyControllerGetLevelPolicyBindingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerGetLevelPolicyBindings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPolicyControllerGetLevelPolicyBindingsForGroupRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	policyUuid string
	groupUuid string
}

func (r ApiPolicyControllerGetLevelPolicyBindingsForGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.PolicyControllerGetLevelPolicyBindingsForGroupExecute(r)
}

/*
PolicyControllerGetLevelPolicyBindingsForGroup Get policy bindings within a level

This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param policyUuid The ID of the required policy.
 @param groupUuid The ID of the required user group.
 @return ApiPolicyControllerGetLevelPolicyBindingsForGroupRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerGetLevelPolicyBindingsForGroup(ctx context.Context, levelType string, levelId string, policyUuid string, groupUuid string) ApiPolicyControllerGetLevelPolicyBindingsForGroupRequest {
	return ApiPolicyControllerGetLevelPolicyBindingsForGroupRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		policyUuid: policyUuid,
		groupUuid: groupUuid,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) PolicyControllerGetLevelPolicyBindingsForGroupExecute(r ApiPolicyControllerGetLevelPolicyBindingsForGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerGetLevelPolicyBindingsForGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/{policyUuid}/{groupUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupUuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPolicyControllerGetPolicyOverviewListRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
}

func (r ApiPolicyControllerGetPolicyOverviewListRequest) Execute() (*PolicyOverviewDtoList, *http.Response, error) {
	return r.ApiService.PolicyControllerGetPolicyOverviewListExecute(r)
}

/*
PolicyControllerGetPolicyOverviewList Lists all policies for a level, including inherited from higher levels

This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @return ApiPolicyControllerGetPolicyOverviewListRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerGetPolicyOverviewList(ctx context.Context, levelType string, levelId string) ApiPolicyControllerGetPolicyOverviewListRequest {
	return ApiPolicyControllerGetPolicyOverviewListRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
	}
}

// Execute executes the request
//  @return PolicyOverviewDtoList
func (a *PolicyManagementAPIService) PolicyControllerGetPolicyOverviewListExecute(r ApiPolicyControllerGetPolicyOverviewListRequest) (*PolicyOverviewDtoList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyOverviewDtoList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerGetPolicyOverviewList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies/aggregate"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPolicyControllerGetPolicyUuidsBindingsRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	groupUuid string
}

func (r ApiPolicyControllerGetPolicyUuidsBindingsRequest) Execute() (*PolicyUuidsWithoutMetadataDto, *http.Response, error) {
	return r.ApiService.PolicyControllerGetPolicyUuidsBindingsExecute(r)
}

/*
PolicyControllerGetPolicyUuidsBindings Lists all policies for a user group

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param groupUuid The ID of the required user group.
 @return ApiPolicyControllerGetPolicyUuidsBindingsRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerGetPolicyUuidsBindings(ctx context.Context, levelType string, levelId string, groupUuid string) ApiPolicyControllerGetPolicyUuidsBindingsRequest {
	return ApiPolicyControllerGetPolicyUuidsBindingsRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		groupUuid: groupUuid,
	}
}

// Execute executes the request
//  @return PolicyUuidsWithoutMetadataDto
func (a *PolicyManagementAPIService) PolicyControllerGetPolicyUuidsBindingsExecute(r ApiPolicyControllerGetPolicyUuidsBindingsRequest) (*PolicyUuidsWithoutMetadataDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PolicyUuidsWithoutMetadataDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerGetPolicyUuidsBindings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/groups/{groupUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupUuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPolicyControllerUpdateLevelPolicyRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	policyUuid string
	createOrUpdateLevelPolicyRequestDto *CreateOrUpdateLevelPolicyRequestDto
}

// The JSON body of the request. Contains the updated configuration of a policy.
func (r ApiPolicyControllerUpdateLevelPolicyRequest) CreateOrUpdateLevelPolicyRequestDto(createOrUpdateLevelPolicyRequestDto CreateOrUpdateLevelPolicyRequestDto) ApiPolicyControllerUpdateLevelPolicyRequest {
	r.createOrUpdateLevelPolicyRequestDto = &createOrUpdateLevelPolicyRequestDto
	return r
}

func (r ApiPolicyControllerUpdateLevelPolicyRequest) Execute() (*LevelPolicyDto, *http.Response, error) {
	return r.ApiService.PolicyControllerUpdateLevelPolicyExecute(r)
}

/*
PolicyControllerUpdateLevelPolicy Updates a policy

If the specified policy doesn't exist, a new one is created.
This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param policyUuid The ID of the required policy.
 @return ApiPolicyControllerUpdateLevelPolicyRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerUpdateLevelPolicy(ctx context.Context, levelType string, levelId string, policyUuid string) ApiPolicyControllerUpdateLevelPolicyRequest {
	return ApiPolicyControllerUpdateLevelPolicyRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return LevelPolicyDto
func (a *PolicyManagementAPIService) PolicyControllerUpdateLevelPolicyExecute(r ApiPolicyControllerUpdateLevelPolicyRequest) (*LevelPolicyDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LevelPolicyDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerUpdateLevelPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrUpdateLevelPolicyRequestDto == nil {
		return localVarReturnValue, nil, reportError("createOrUpdateLevelPolicyRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrUpdateLevelPolicyRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPolicyControllerUpdateLevelPolicyBindingsRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	createLevelPolicyBindingsRequestDto *CreateLevelPolicyBindingsRequestDto
}

// The JSON body of the request. Contains new policy bindings of a level.    Any existing binding not presented in the request is discarded.
func (r ApiPolicyControllerUpdateLevelPolicyBindingsRequest) CreateLevelPolicyBindingsRequestDto(createLevelPolicyBindingsRequestDto CreateLevelPolicyBindingsRequestDto) ApiPolicyControllerUpdateLevelPolicyBindingsRequest {
	r.createLevelPolicyBindingsRequestDto = &createLevelPolicyBindingsRequestDto
	return r
}

func (r ApiPolicyControllerUpdateLevelPolicyBindingsRequest) Execute() (*http.Response, error) {
	return r.ApiService.PolicyControllerUpdateLevelPolicyBindingsExecute(r)
}

/*
PolicyControllerUpdateLevelPolicyBindings Updates policy bindings of a level

The request overwrites all existing bindings.
 This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @return ApiPolicyControllerUpdateLevelPolicyBindingsRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerUpdateLevelPolicyBindings(ctx context.Context, levelType string, levelId string) ApiPolicyControllerUpdateLevelPolicyBindingsRequest {
	return ApiPolicyControllerUpdateLevelPolicyBindingsRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) PolicyControllerUpdateLevelPolicyBindingsExecute(r ApiPolicyControllerUpdateLevelPolicyBindingsRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerUpdateLevelPolicyBindings")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createLevelPolicyBindingsRequestDto == nil {
		return nil, reportError("createLevelPolicyBindingsRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createLevelPolicyBindingsRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPolicyControllerUpdatePolicyBindingsToGroupRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	groupUuid string
	policyUuidsDto *PolicyUuidsDto
}

// The JSON body of the request. Contains new policies for the group.    Any policy not presented in the request is discarded.
func (r ApiPolicyControllerUpdatePolicyBindingsToGroupRequest) PolicyUuidsDto(policyUuidsDto PolicyUuidsDto) ApiPolicyControllerUpdatePolicyBindingsToGroupRequest {
	r.policyUuidsDto = &policyUuidsDto
	return r
}

func (r ApiPolicyControllerUpdatePolicyBindingsToGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.PolicyControllerUpdatePolicyBindingsToGroupExecute(r)
}

/*
PolicyControllerUpdatePolicyBindingsToGroup Updates policies for a user group

The request overwrites existing policies.
This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `global`: A global policy applies to all accounts and environments. It is defined and managed by Dynatrace.  * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * global: use the `global` value.  * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param groupUuid The ID of the required user group.
 @return ApiPolicyControllerUpdatePolicyBindingsToGroupRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerUpdatePolicyBindingsToGroup(ctx context.Context, levelType string, levelId string, groupUuid string) ApiPolicyControllerUpdatePolicyBindingsToGroupRequest {
	return ApiPolicyControllerUpdatePolicyBindingsToGroupRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		groupUuid: groupUuid,
	}
}

// Execute executes the request
func (a *PolicyManagementAPIService) PolicyControllerUpdatePolicyBindingsToGroupExecute(r ApiPolicyControllerUpdatePolicyBindingsToGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerUpdatePolicyBindingsToGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/bindings/groups/{groupUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"groupUuid"+"}", url.PathEscape(parameterValueToString(r.groupUuid, "groupUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.policyUuidsDto == nil {
		return nil, reportError("policyUuidsDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.policyUuidsDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPolicyControllerValidateLevelPolicyRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	policyUuid string
	createOrUpdateLevelPolicyRequestDto *CreateOrUpdateLevelPolicyRequestDto
}

// The JSON body of the request. Contains the configuration of a policy to be validated.
func (r ApiPolicyControllerValidateLevelPolicyRequest) CreateOrUpdateLevelPolicyRequestDto(createOrUpdateLevelPolicyRequestDto CreateOrUpdateLevelPolicyRequestDto) ApiPolicyControllerValidateLevelPolicyRequest {
	r.createOrUpdateLevelPolicyRequestDto = &createOrUpdateLevelPolicyRequestDto
	return r
}

func (r ApiPolicyControllerValidateLevelPolicyRequest) Execute() (*ValidationDto, *http.Response, error) {
	return r.ApiService.PolicyControllerValidateLevelPolicyExecute(r)
}

/*
PolicyControllerValidateLevelPolicy Validates the payload for the `PUT /iam/v1/repo/{levelType}/{levelId}/policies/{policyUuid}` request

This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
 @param policyUuid The ID of the policy to be validated.
 @return ApiPolicyControllerValidateLevelPolicyRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerValidateLevelPolicy(ctx context.Context, levelType string, levelId string, policyUuid string) ApiPolicyControllerValidateLevelPolicyRequest {
	return ApiPolicyControllerValidateLevelPolicyRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
		policyUuid: policyUuid,
	}
}

// Execute executes the request
//  @return ValidationDto
func (a *PolicyManagementAPIService) PolicyControllerValidateLevelPolicyExecute(r ApiPolicyControllerValidateLevelPolicyRequest) (*ValidationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerValidateLevelPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies/validation/{policyUuid}"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"policyUuid"+"}", url.PathEscape(parameterValueToString(r.policyUuid, "policyUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrUpdateLevelPolicyRequestDto == nil {
		return localVarReturnValue, nil, reportError("createOrUpdateLevelPolicyRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrUpdateLevelPolicyRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPolicyControllerValidateNewLevelPolicyRequest struct {
	ctx context.Context
	ApiService *PolicyManagementAPIService
	levelType string
	levelId string
	createOrUpdateLevelPolicyRequestDto *CreateOrUpdateLevelPolicyRequestDto
}

// The JSON body of the request. Contains the configuration of a policy to be validated.
func (r ApiPolicyControllerValidateNewLevelPolicyRequest) CreateOrUpdateLevelPolicyRequestDto(createOrUpdateLevelPolicyRequestDto CreateOrUpdateLevelPolicyRequestDto) ApiPolicyControllerValidateNewLevelPolicyRequest {
	r.createOrUpdateLevelPolicyRequestDto = &createOrUpdateLevelPolicyRequestDto
	return r
}

func (r ApiPolicyControllerValidateNewLevelPolicyRequest) Execute() (*ValidationDto, *http.Response, error) {
	return r.ApiService.PolicyControllerValidateNewLevelPolicyExecute(r)
}

/*
PolicyControllerValidateNewLevelPolicy Validates the payload for the `POST /iam/v1/repo/{levelType}/{levelId}/policies` request

This endpoint is unavailable within global level

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param levelType The type of the [policy](https://dt-url.net/eu03uap) level. The following values are available:   * `account`: An account policy applies to all environments of an account.  * `environment`: An environment policy applies to a specific environment.    Each level inherits the policies of the higher level and extends them with its own policies.
 @param levelId The ID of the policy level. Use one of the following values, depending on the level type:   * account: use the UUID of the account.  * environment: use the ID of the environment.
 @return ApiPolicyControllerValidateNewLevelPolicyRequest
*/
func (a *PolicyManagementAPIService) PolicyControllerValidateNewLevelPolicy(ctx context.Context, levelType string, levelId string) ApiPolicyControllerValidateNewLevelPolicyRequest {
	return ApiPolicyControllerValidateNewLevelPolicyRequest{
		ApiService: a,
		ctx: ctx,
		levelType: levelType,
		levelId: levelId,
	}
}

// Execute executes the request
//  @return ValidationDto
func (a *PolicyManagementAPIService) PolicyControllerValidateNewLevelPolicyExecute(r ApiPolicyControllerValidateNewLevelPolicyRequest) (*ValidationDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ValidationDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PolicyManagementAPIService.PolicyControllerValidateNewLevelPolicy")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/iam/v1/repo/{levelType}/{levelId}/policies/validation"
	localVarPath = strings.Replace(localVarPath, "{"+"levelType"+"}", url.PathEscape(parameterValueToString(r.levelType, "levelType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"levelId"+"}", url.PathEscape(parameterValueToString(r.levelId, "levelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createOrUpdateLevelPolicyRequestDto == nil {
		return localVarReturnValue, nil, reportError("createOrUpdateLevelPolicyRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createOrUpdateLevelPolicyRequestDto
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v ErrorDto
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
