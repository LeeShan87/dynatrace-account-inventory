/*
Dynatrace Configuration API

Documentation of the Dynatrace Configuration API. To read about use-cases and examples, see [Dynatrace Documentation](https://dt-url.net/4u43kxw).  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package configv1

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ServiceDetectionOpaqueAndExternalWebServiceAPIService ServiceDetectionOpaqueAndExternalWebServiceAPI service
type ServiceDetectionOpaqueAndExternalWebServiceAPIService service

type ApiCreateOpaqueAndExternalWebServiceRuleRequest struct {
	ctx context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceAPIService
	position *string
	opaqueAndExternalWebServiceRule *OpaqueAndExternalWebServiceRule
}

// The position of the new rule:    * &#x60;APPEND&#x60;: at the end of the rule list.   * &#x60;PREPEND&#x60;: on top of the rule list.   
func (r ApiCreateOpaqueAndExternalWebServiceRuleRequest) Position(position string) ApiCreateOpaqueAndExternalWebServiceRuleRequest {
	r.position = &position
	return r
}

// The JSON body of the request containing parameters of the new service detection rule.    You must not specify the ID of the rule!   The **order** field is ignored in this request. To enforce a particular order use the &#x60;PUT /ruleBasedServiceDetection/OPAQUE_AND_EXTERNAL_WEB_SERVICE/reorder&#x60; request.
func (r ApiCreateOpaqueAndExternalWebServiceRuleRequest) OpaqueAndExternalWebServiceRule(opaqueAndExternalWebServiceRule OpaqueAndExternalWebServiceRule) ApiCreateOpaqueAndExternalWebServiceRuleRequest {
	r.opaqueAndExternalWebServiceRule = &opaqueAndExternalWebServiceRule
	return r
}

func (r ApiCreateOpaqueAndExternalWebServiceRuleRequest) Execute() (*EntityShortRepresentation, *http.Response, error) {
	return r.ApiService.CreateOpaqueAndExternalWebServiceRuleExecute(r)
}

/*
CreateOpaqueAndExternalWebServiceRule Creates a new service detection rule

The body must not provide an ID as it will be automatically assigned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOpaqueAndExternalWebServiceRuleRequest
*/
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) CreateOpaqueAndExternalWebServiceRule(ctx context.Context) ApiCreateOpaqueAndExternalWebServiceRuleRequest {
	return ApiCreateOpaqueAndExternalWebServiceRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EntityShortRepresentation
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) CreateOpaqueAndExternalWebServiceRuleExecute(r ApiCreateOpaqueAndExternalWebServiceRuleRequest) (*EntityShortRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntityShortRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceAPIService.CreateOpaqueAndExternalWebServiceRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.position != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "position", r.position, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opaqueAndExternalWebServiceRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOpaqueAndExternalWebServiceRuleRequest struct {
	ctx context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceAPIService
	id string
}

func (r ApiDeleteOpaqueAndExternalWebServiceRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteOpaqueAndExternalWebServiceRuleExecute(r)
}

/*
DeleteOpaqueAndExternalWebServiceRule Deletes the specified service detection rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the service detection rule to be deleted.
 @return ApiDeleteOpaqueAndExternalWebServiceRuleRequest
*/
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) DeleteOpaqueAndExternalWebServiceRule(ctx context.Context, id string) ApiDeleteOpaqueAndExternalWebServiceRuleRequest {
	return ApiDeleteOpaqueAndExternalWebServiceRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) DeleteOpaqueAndExternalWebServiceRuleExecute(r ApiDeleteOpaqueAndExternalWebServiceRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceAPIService.DeleteOpaqueAndExternalWebServiceRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetOpaqueAndExternalWebServiceRuleRequest struct {
	ctx context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceAPIService
	id string
}

func (r ApiGetOpaqueAndExternalWebServiceRuleRequest) Execute() (*OpaqueAndExternalWebServiceRule, *http.Response, error) {
	return r.ApiService.GetOpaqueAndExternalWebServiceRuleExecute(r)
}

/*
GetOpaqueAndExternalWebServiceRule Shows the properties of the specified service detection rule

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the required service detection rule.
 @return ApiGetOpaqueAndExternalWebServiceRuleRequest
*/
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) GetOpaqueAndExternalWebServiceRule(ctx context.Context, id string) ApiGetOpaqueAndExternalWebServiceRuleRequest {
	return ApiGetOpaqueAndExternalWebServiceRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return OpaqueAndExternalWebServiceRule
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) GetOpaqueAndExternalWebServiceRuleExecute(r ApiGetOpaqueAndExternalWebServiceRuleRequest) (*OpaqueAndExternalWebServiceRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OpaqueAndExternalWebServiceRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceAPIService.GetOpaqueAndExternalWebServiceRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOpaqueAndExternalWebServiceRulesRequest struct {
	ctx context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceAPIService
}

func (r ApiListOpaqueAndExternalWebServiceRulesRequest) Execute() (*StubList, *http.Response, error) {
	return r.ApiService.ListOpaqueAndExternalWebServiceRulesExecute(r)
}

/*
ListOpaqueAndExternalWebServiceRules Lists all opaque and external web service detection rules

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListOpaqueAndExternalWebServiceRulesRequest
*/
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) ListOpaqueAndExternalWebServiceRules(ctx context.Context) ApiListOpaqueAndExternalWebServiceRulesRequest {
	return ApiListOpaqueAndExternalWebServiceRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return StubList
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) ListOpaqueAndExternalWebServiceRulesExecute(r ApiListOpaqueAndExternalWebServiceRulesRequest) (*StubList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StubList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceAPIService.ListOpaqueAndExternalWebServiceRules")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiOrderOpaqueAndExternalWebServiceRulesRequest struct {
	ctx context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceAPIService
	stubList *StubList
}

// The JSON body of the request containing the service detection rules in the required order.
func (r ApiOrderOpaqueAndExternalWebServiceRulesRequest) StubList(stubList StubList) ApiOrderOpaqueAndExternalWebServiceRulesRequest {
	r.stubList = &stubList
	return r
}

func (r ApiOrderOpaqueAndExternalWebServiceRulesRequest) Execute() (*http.Response, error) {
	return r.ApiService.OrderOpaqueAndExternalWebServiceRulesExecute(r)
}

/*
OrderOpaqueAndExternalWebServiceRules Reorders the service detection rules of the specified type

The request reorders the rules of the specified type according to the order of the IDs in the body of the request. 

 Rules that are omitted in the body of the request will retain their relative order but will be placed *after* all those present in the request.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiOrderOpaqueAndExternalWebServiceRulesRequest
*/
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) OrderOpaqueAndExternalWebServiceRules(ctx context.Context) ApiOrderOpaqueAndExternalWebServiceRulesRequest {
	return ApiOrderOpaqueAndExternalWebServiceRulesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) OrderOpaqueAndExternalWebServiceRulesExecute(r ApiOrderOpaqueAndExternalWebServiceRulesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceAPIService.OrderOpaqueAndExternalWebServiceRules")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.stubList
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateOpaqueAndExternalWebServiceRuleRequest struct {
	ctx context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceAPIService
	id string
	opaqueAndExternalWebServiceRule *OpaqueAndExternalWebServiceRule
}

// The JSON body of the request containing updated parameters of the service detection rule.
func (r ApiUpdateOpaqueAndExternalWebServiceRuleRequest) OpaqueAndExternalWebServiceRule(opaqueAndExternalWebServiceRule OpaqueAndExternalWebServiceRule) ApiUpdateOpaqueAndExternalWebServiceRuleRequest {
	r.opaqueAndExternalWebServiceRule = &opaqueAndExternalWebServiceRule
	return r
}

func (r ApiUpdateOpaqueAndExternalWebServiceRuleRequest) Execute() (*EntityShortRepresentation, *http.Response, error) {
	return r.ApiService.UpdateOpaqueAndExternalWebServiceRuleExecute(r)
}

/*
UpdateOpaqueAndExternalWebServiceRule Updates an existing service detection rule

If the rule with the specified ID doesn't exist, a new rule will be created and appended to the end of the rule list. 

 The request keeps an existing order of rules, unless the **order** parameter is set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the rule to be updated.
 @return ApiUpdateOpaqueAndExternalWebServiceRuleRequest
*/
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) UpdateOpaqueAndExternalWebServiceRule(ctx context.Context, id string) ApiUpdateOpaqueAndExternalWebServiceRuleRequest {
	return ApiUpdateOpaqueAndExternalWebServiceRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return EntityShortRepresentation
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) UpdateOpaqueAndExternalWebServiceRuleExecute(r ApiUpdateOpaqueAndExternalWebServiceRuleRequest) (*EntityShortRepresentation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EntityShortRepresentation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceAPIService.UpdateOpaqueAndExternalWebServiceRule")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opaqueAndExternalWebServiceRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest struct {
	ctx context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceAPIService
	opaqueAndExternalWebServiceRule *OpaqueAndExternalWebServiceRule
}

func (r ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest) OpaqueAndExternalWebServiceRule(opaqueAndExternalWebServiceRule OpaqueAndExternalWebServiceRule) ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest {
	r.opaqueAndExternalWebServiceRule = &opaqueAndExternalWebServiceRule
	return r
}

func (r ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidateCreateOpaqueAndExternalWebServiceRuleExecute(r)
}

/*
ValidateCreateOpaqueAndExternalWebServiceRule Validates the payload for the `POST /ruleBasedServiceDetection/OPAQUE_AND_EXTERNAL_WEB_SERVICE` request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest
*/
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) ValidateCreateOpaqueAndExternalWebServiceRule(ctx context.Context) ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest {
	return ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) ValidateCreateOpaqueAndExternalWebServiceRuleExecute(r ApiValidateCreateOpaqueAndExternalWebServiceRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceAPIService.ValidateCreateOpaqueAndExternalWebServiceRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE/validator"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.opaqueAndExternalWebServiceRule == nil {
		return nil, reportError("opaqueAndExternalWebServiceRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opaqueAndExternalWebServiceRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest struct {
	ctx context.Context
	ApiService *ServiceDetectionOpaqueAndExternalWebServiceAPIService
	id string
	opaqueAndExternalWebServiceRule *OpaqueAndExternalWebServiceRule
}

func (r ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest) OpaqueAndExternalWebServiceRule(opaqueAndExternalWebServiceRule OpaqueAndExternalWebServiceRule) ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest {
	r.opaqueAndExternalWebServiceRule = &opaqueAndExternalWebServiceRule
	return r
}

func (r ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest) Execute() (*http.Response, error) {
	return r.ApiService.ValidateUpdateOpaqueAndExternalWebServiceRuleExecute(r)
}

/*
ValidateUpdateOpaqueAndExternalWebServiceRule Validate the payload for the `PUT /ruleBasedServiceDetection/OPAQUE_AND_EXTERNAL_WEB_SERVICE/{id}` request

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the service detection rule to be validated.
 @return ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest
*/
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) ValidateUpdateOpaqueAndExternalWebServiceRule(ctx context.Context, id string) ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest {
	return ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ServiceDetectionOpaqueAndExternalWebServiceAPIService) ValidateUpdateOpaqueAndExternalWebServiceRuleExecute(r ApiValidateUpdateOpaqueAndExternalWebServiceRuleRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceDetectionOpaqueAndExternalWebServiceAPIService.ValidateUpdateOpaqueAndExternalWebServiceRule")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/service/detectionRules/OPAQUE_AND_EXTERNAL_WEB_SERVICE/{id}/validator"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.opaqueAndExternalWebServiceRule == nil {
		return nil, reportError("opaqueAndExternalWebServiceRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.opaqueAndExternalWebServiceRule
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
