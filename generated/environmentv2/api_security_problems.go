/*
Dynatrace Environment API

 Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package environmentv2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SecurityProblemsAPIService SecurityProblemsAPI service
type SecurityProblemsAPIService service

type ApiBulkMuteRemediationItemsRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	id string
	remediationItemsBulkMute *RemediationItemsBulkMute
}

// The JSON body of the request. Contains the muting information.
func (r ApiBulkMuteRemediationItemsRequest) RemediationItemsBulkMute(remediationItemsBulkMute RemediationItemsBulkMute) ApiBulkMuteRemediationItemsRequest {
	r.remediationItemsBulkMute = &remediationItemsBulkMute
	return r
}

func (r ApiBulkMuteRemediationItemsRequest) Execute() (*RemediationItemsBulkMuteResponse, *http.Response, error) {
	return r.ApiService.BulkMuteRemediationItemsExecute(r)
}

/*
BulkMuteRemediationItems Mutes several remediation items

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the required third-party security problem.
 @return ApiBulkMuteRemediationItemsRequest
*/
func (a *SecurityProblemsAPIService) BulkMuteRemediationItems(ctx context.Context, id string) ApiBulkMuteRemediationItemsRequest {
	return ApiBulkMuteRemediationItemsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RemediationItemsBulkMuteResponse
func (a *SecurityProblemsAPIService) BulkMuteRemediationItemsExecute(r ApiBulkMuteRemediationItemsRequest) (*RemediationItemsBulkMuteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemediationItemsBulkMuteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.BulkMuteRemediationItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/{id}/remediationItems/mute"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.remediationItemsBulkMute
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkMuteSecurityProblemsRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	securityProblemsBulkMute *SecurityProblemsBulkMute
}

// The JSON body of the request. Contains the muting information.
func (r ApiBulkMuteSecurityProblemsRequest) SecurityProblemsBulkMute(securityProblemsBulkMute SecurityProblemsBulkMute) ApiBulkMuteSecurityProblemsRequest {
	r.securityProblemsBulkMute = &securityProblemsBulkMute
	return r
}

func (r ApiBulkMuteSecurityProblemsRequest) Execute() (*SecurityProblemsBulkMuteResponse, *http.Response, error) {
	return r.ApiService.BulkMuteSecurityProblemsExecute(r)
}

/*
BulkMuteSecurityProblems Mutes several security problems

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkMuteSecurityProblemsRequest
*/
func (a *SecurityProblemsAPIService) BulkMuteSecurityProblems(ctx context.Context) ApiBulkMuteSecurityProblemsRequest {
	return ApiBulkMuteSecurityProblemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecurityProblemsBulkMuteResponse
func (a *SecurityProblemsAPIService) BulkMuteSecurityProblemsExecute(r ApiBulkMuteSecurityProblemsRequest) (*SecurityProblemsBulkMuteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityProblemsBulkMuteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.BulkMuteSecurityProblems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/mute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.securityProblemsBulkMute
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkUnmuteRemediationItemsRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	id string
	remediationItemsBulkUnmute *RemediationItemsBulkUnmute
}

// The JSON body of the request. Contains the un-muting information.
func (r ApiBulkUnmuteRemediationItemsRequest) RemediationItemsBulkUnmute(remediationItemsBulkUnmute RemediationItemsBulkUnmute) ApiBulkUnmuteRemediationItemsRequest {
	r.remediationItemsBulkUnmute = &remediationItemsBulkUnmute
	return r
}

func (r ApiBulkUnmuteRemediationItemsRequest) Execute() (*RemediationItemsBulkUnmuteResponse, *http.Response, error) {
	return r.ApiService.BulkUnmuteRemediationItemsExecute(r)
}

/*
BulkUnmuteRemediationItems Un-mutes several remediation items

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the required third-party security problem.
 @return ApiBulkUnmuteRemediationItemsRequest
*/
func (a *SecurityProblemsAPIService) BulkUnmuteRemediationItems(ctx context.Context, id string) ApiBulkUnmuteRemediationItemsRequest {
	return ApiBulkUnmuteRemediationItemsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RemediationItemsBulkUnmuteResponse
func (a *SecurityProblemsAPIService) BulkUnmuteRemediationItemsExecute(r ApiBulkUnmuteRemediationItemsRequest) (*RemediationItemsBulkUnmuteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemediationItemsBulkUnmuteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.BulkUnmuteRemediationItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/{id}/remediationItems/unmute"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.remediationItemsBulkUnmute
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBulkUnmuteSecurityProblemsRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	securityProblemsBulkUnmute *SecurityProblemsBulkUnmute
}

// The JSON body of the request. Contains the un-muting information.
func (r ApiBulkUnmuteSecurityProblemsRequest) SecurityProblemsBulkUnmute(securityProblemsBulkUnmute SecurityProblemsBulkUnmute) ApiBulkUnmuteSecurityProblemsRequest {
	r.securityProblemsBulkUnmute = &securityProblemsBulkUnmute
	return r
}

func (r ApiBulkUnmuteSecurityProblemsRequest) Execute() (*SecurityProblemsBulkUnmuteResponse, *http.Response, error) {
	return r.ApiService.BulkUnmuteSecurityProblemsExecute(r)
}

/*
BulkUnmuteSecurityProblems Un-mutes several security problems

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBulkUnmuteSecurityProblemsRequest
*/
func (a *SecurityProblemsAPIService) BulkUnmuteSecurityProblems(ctx context.Context) ApiBulkUnmuteSecurityProblemsRequest {
	return ApiBulkUnmuteSecurityProblemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecurityProblemsBulkUnmuteResponse
func (a *SecurityProblemsAPIService) BulkUnmuteSecurityProblemsExecute(r ApiBulkUnmuteSecurityProblemsRequest) (*SecurityProblemsBulkUnmuteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityProblemsBulkUnmuteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.BulkUnmuteSecurityProblems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/unmute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.securityProblemsBulkUnmute
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetEventsForSecurityProblemRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	id string
	from *string
	to *string
}

// The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of thirty days is used (&#x60;now-30d&#x60;).
func (r ApiGetEventsForSecurityProblemRequest) From(from string) ApiGetEventsForSecurityProblemRequest {
	r.from = &from
	return r
}

// The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used.
func (r ApiGetEventsForSecurityProblemRequest) To(to string) ApiGetEventsForSecurityProblemRequest {
	r.to = &to
	return r
}

func (r ApiGetEventsForSecurityProblemRequest) Execute() (*SecurityProblemEventsList, *http.Response, error) {
	return r.ApiService.GetEventsForSecurityProblemExecute(r)
}

/*
GetEventsForSecurityProblem Lists all events of a security problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the required security problem.
 @return ApiGetEventsForSecurityProblemRequest
*/
func (a *SecurityProblemsAPIService) GetEventsForSecurityProblem(ctx context.Context, id string) ApiGetEventsForSecurityProblemRequest {
	return ApiGetEventsForSecurityProblemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SecurityProblemEventsList
func (a *SecurityProblemsAPIService) GetEventsForSecurityProblemExecute(r ApiGetEventsForSecurityProblemRequest) (*SecurityProblemEventsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityProblemEventsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.GetEventsForSecurityProblem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/{id}/events"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRemediationItemRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	id string
	remediationItemId string
}

func (r ApiGetRemediationItemRequest) Execute() (*RemediationDetailsItem, *http.Response, error) {
	return r.ApiService.GetRemediationItemExecute(r)
}

/*
GetRemediationItem Gets parameters of a remediation item of a security problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the required third-party security problem.
 @param remediationItemId The ID of the remediation item.
 @return ApiGetRemediationItemRequest
*/
func (a *SecurityProblemsAPIService) GetRemediationItem(ctx context.Context, id string, remediationItemId string) ApiGetRemediationItemRequest {
	return ApiGetRemediationItemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		remediationItemId: remediationItemId,
	}
}

// Execute executes the request
//  @return RemediationDetailsItem
func (a *SecurityProblemsAPIService) GetRemediationItemExecute(r ApiGetRemediationItemRequest) (*RemediationDetailsItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemediationDetailsItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.GetRemediationItem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/{id}/remediationItems/{remediationItemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"remediationItemId"+"}", url.PathEscape(parameterValueToString(r.remediationItemId, "remediationItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRemediationItemsRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	id string
	remediationItemSelector *string
}

// Defines the scope of the query. Only remediable entities matching the specified criteria are included in the response.  You can add one or more of the following criteria. Values are *not* case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.  * Vulnerability state: &#x60;vulnerabilityState(\&quot;value\&quot;)&#x60;. Find the possible values in the description of the **vulnerabilityState** field of the response. If not set, all entities are returned. * Muted: &#x60;muted(\&quot;value\&quot;)&#x60;. Possible values are &#x60;TRUE&#x60; or &#x60;FALSE&#x60;. * Reachable data asset assessment: &#x60;assessment.dataAssets(\&quot;value\&quot;)&#x60; Possible values are &#x60;REACHABLE&#x60;, and &#x60;NOT_DETECTED&#x60;. * Network exposure assessment: &#x60;assessment.exposure(\&quot;value\&quot;)&#x60; Possible values are &#x60;PUBLIC_NETWORK&#x60;, and &#x60;NOT_DETECTED&#x60;. * Vulnerable function usage assessment: &#x60;assessment.vulnerableFunctionUsage(\&quot;value\&quot;)&#x60; Possible values are &#x60;IN_USE&#x60;, and &#x60;NOT_IN_USE&#x60;. * Vulnerable function in use contains: &#x60;assessment.vulnerableFunctionInUseContains(\&quot;value\&quot;)&#x60;. Possible values are &#x60;class::function&#x60;, &#x60;class::&#x60; and &#x60;function&#x60;. The &#x60;CONTAINS&#x60; operator is used. Only vulnerable functions in use are considered. * Assessment accuracy: &#x60;assessment.accuracy(\&quot;value\&quot;)&#x60; Possible values are &#x60;FULL&#x60; and &#x60;REDUCED&#x60;. * Entity name contains: &#x60;entityNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used.  To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.  Specify the value of a criterion as a quoted string. The following special characters must be escaped with a tilde (&#x60;~&#x60;) inside quotes: * Tilde &#x60;~&#x60;  * Quote &#x60;\&quot;&#x60;
func (r ApiGetRemediationItemsRequest) RemediationItemSelector(remediationItemSelector string) ApiGetRemediationItemsRequest {
	r.remediationItemSelector = &remediationItemSelector
	return r
}

func (r ApiGetRemediationItemsRequest) Execute() (*RemediationItemList, *http.Response, error) {
	return r.ApiService.GetRemediationItemsExecute(r)
}

/*
GetRemediationItems Lists remediation items of a third-party security problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the required third-party security problem.
 @return ApiGetRemediationItemsRequest
*/
func (a *SecurityProblemsAPIService) GetRemediationItems(ctx context.Context, id string) ApiGetRemediationItemsRequest {
	return ApiGetRemediationItemsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return RemediationItemList
func (a *SecurityProblemsAPIService) GetRemediationItemsExecute(r ApiGetRemediationItemsRequest) (*RemediationItemList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemediationItemList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.GetRemediationItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/{id}/remediationItems"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.remediationItemSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remediationItemSelector", r.remediationItemSelector, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRemediationProgressEntitiesRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	id string
	remediationItemId string
	remediationProgressEntitySelector *string
}

// Defines the scope of the query. Only remediation progress entities matching the specified criteria are included in the response.  You can add one or more of the following criteria. Values are *not* case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.  * State: &#x60;state(\&quot;value\&quot;)&#x60;. Possible values the **state** field are &#x60;AFFECTED&#x60; and &#x60;UNAFFECTED&#x60;. If not set, all entities are returned. * Vulnerable function usage assessment: &#x60;assessment.vulnerableFunctionUsage(\&quot;value\&quot;)&#x60; Possible values are &#x60;IN_USE&#x60;, and &#x60;NOT_IN_USE&#x60;. * Vulnerable function in use contains: &#x60;assessment.vulnerableFunctionInUseContains(\&quot;value\&quot;)&#x60;. Possible values are &#x60;class::function&#x60;, &#x60;class::&#x60; and &#x60;function&#x60;. The &#x60;CONTAINS&#x60; operator is used. Only vulnerable functions in use are considered. * Entity name contains: &#x60;entityNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used.  To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.  Specify the value of a criterion as a quoted string. The following special characters must be escaped with a tilde (&#x60;~&#x60;) inside quotes: * Tilde &#x60;~&#x60;  * Quote &#x60;\&quot;&#x60;
func (r ApiGetRemediationProgressEntitiesRequest) RemediationProgressEntitySelector(remediationProgressEntitySelector string) ApiGetRemediationProgressEntitiesRequest {
	r.remediationProgressEntitySelector = &remediationProgressEntitySelector
	return r
}

func (r ApiGetRemediationProgressEntitiesRequest) Execute() (*RemediationProgressEntityList, *http.Response, error) {
	return r.ApiService.GetRemediationProgressEntitiesExecute(r)
}

/*
GetRemediationProgressEntities Lists remediation progress entities

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the required third-party security problem.
 @param remediationItemId The ID of the remediation item.
 @return ApiGetRemediationProgressEntitiesRequest
*/
func (a *SecurityProblemsAPIService) GetRemediationProgressEntities(ctx context.Context, id string, remediationItemId string) ApiGetRemediationProgressEntitiesRequest {
	return ApiGetRemediationProgressEntitiesRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		remediationItemId: remediationItemId,
	}
}

// Execute executes the request
//  @return RemediationProgressEntityList
func (a *SecurityProblemsAPIService) GetRemediationProgressEntitiesExecute(r ApiGetRemediationProgressEntitiesRequest) (*RemediationProgressEntityList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RemediationProgressEntityList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.GetRemediationProgressEntities")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/{id}/remediationItems/{remediationItemId}/remediationProgressEntities"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"remediationItemId"+"}", url.PathEscape(parameterValueToString(r.remediationItemId, "remediationItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.remediationProgressEntitySelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "remediationProgressEntitySelector", r.remediationProgressEntitySelector, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSecurityProblemRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	id string
	fields *string
	from *string
}

// A list of additional security problem properties you can add to the response.  The following properties are available (all other properties are always included and you can&#39;t remove them from the response):  * &#x60;riskAssessment&#x60;: A risk assessment of the security problem. * &#x60;managementZones&#x60;: The management zone where the security problem occurred. * &#x60;codeLevelVulnerabilityDetails&#x60;: Details of the code-level vulnerability. * &#x60;globalCounts&#x60;: Globally calculated statistics about the security problem. No management zone information is taken into account. * &#x60;filteredCounts&#x60;: Statistics about the security problem, filtered by the management zone and timeframe start (&#39;from&#39;) query parameters.  * &#x60;description&#x60;: The description of the vulnerability. * &#x60;events&#x60;: The security problem&#39;s last 10 events within the last 365 days, sorted from newest to oldest. * &#x60;vulnerableComponents&#x60;: A list of vulnerable components of the security problem within the provided filter range.  * &#x60;affectedEntities&#x60;: A list of affected entities of the security problem within the provided filter range.  * &#x60;exposedEntities&#x60;: A list of exposed entities of the security problem within the provided filter range.  * &#x60;reachableDataAssets&#x60;: A list of data assets reachable by affected entities of the security problem within the provided filter range.  * &#x60;relatedEntities&#x60;: A list of related entities of the security problem within the provided filter range.  * &#x60;relatedContainerImages&#x60;: A list of related container images of the security problem within the provided filter range.  * &#x60;relatedAttacks&#x60;: A list of attacks detected on the exposed security problem.  * &#x60;entryPoints&#x60;: A list of entry points and a flag which indicates whether this list was truncated or not.  To add properties, specify them in a comma-separated list and prefix each property with a plus (for example, &#x60;+riskAssessment,+managementZones&#x60;). 
func (r ApiGetSecurityProblemRequest) Fields(fields string) ApiGetSecurityProblemRequest {
	r.fields = &fields
	return r
}

// Based on the timeframe start the affected-, related- and vulnerable entities are being calculated. You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the default timeframe start of 24 hours in the past is used (&#x60;now-24h&#x60;).  The timeframe start must not be older than 365 days.
func (r ApiGetSecurityProblemRequest) From(from string) ApiGetSecurityProblemRequest {
	r.from = &from
	return r
}

func (r ApiGetSecurityProblemRequest) Execute() (*SecurityProblemDetails, *http.Response, error) {
	return r.ApiService.GetSecurityProblemExecute(r)
}

/*
GetSecurityProblem Gets parameters of a security problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the required security problem.
 @return ApiGetSecurityProblemRequest
*/
func (a *SecurityProblemsAPIService) GetSecurityProblem(ctx context.Context, id string) ApiGetSecurityProblemRequest {
	return ApiGetSecurityProblemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return SecurityProblemDetails
func (a *SecurityProblemsAPIService) GetSecurityProblemExecute(r ApiGetSecurityProblemRequest) (*SecurityProblemDetails, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityProblemDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.GetSecurityProblem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSecurityProblemsRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	nextPageKey *string
	pageSize *int64
	securityProblemSelector *string
	sort *string
	fields *string
	from *string
	to *string
}

// The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters. 
func (r ApiGetSecurityProblemsRequest) NextPageKey(nextPageKey string) ApiGetSecurityProblemsRequest {
	r.nextPageKey = &nextPageKey
	return r
}

// The amount of security problems in a single response payload.   The maximal allowed page size is 500.   If not set, 100 is used.
func (r ApiGetSecurityProblemsRequest) PageSize(pageSize int64) ApiGetSecurityProblemsRequest {
	r.pageSize = &pageSize
	return r
}

// Defines the scope of the query. Only security problems matching the specified criteria are included in the response.  You can add one or more of the following criteria. Values are *not* case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.  * Status: &#x60;status(\&quot;value\&quot;)&#x60;. Find the possible values in the description of the **status** field of the response. If not set, all security problems are returned. * Muted: &#x60;muted(\&quot;value\&quot;)&#x60;. Possible values are &#x60;TRUE&#x60; or &#x60;FALSE&#x60;. * Risk level: &#x60;riskLevel(\&quot;value\&quot;)&#x60;. The Davis risk level. Find the possible values in the description of the **riskLevel** field of the response. * Minimum risk score: &#x60;minRiskScore(\&quot;5.5\&quot;)&#x60;. The Davis minimum risk score. The &#x60;GREATER THAN OR EQUAL TO&#x60; operator is used. Specify a number between &#x60;1.0&#x60; and &#x60;10.0&#x60;. * Maximum risk score: &#x60;maxRiskScore(\&quot;5.5\&quot;)&#x60;. The Davis maximum risk score. The &#x60;LESS THAN&#x60; operator is used. Specify a number between &#x60;1.0&#x60; and &#x60;10.0&#x60;. * Base risk level: &#x60;baseRiskLevel(\&quot;value\&quot;)&#x60;. The Base risk level from the CVSS. Find the possible values in the description of the **riskLevel** field of the response. * Minimum base risk score: &#x60;minBaseRiskScore(\&quot;5.5\&quot;)&#x60;. The minimum base risk score from the CVSS. The &#x60;GREATER THAN OR EQUAL TO&#x60; operator is used. Specify a number between &#x60;1.0&#x60; and &#x60;10.0&#x60;. * Maximum base risk score: &#x60;maxBaseRiskScore(\&quot;5.5\&quot;)&#x60;. The maximum base risk score from the CVSS. The &#x60;LESS THAN&#x60; operator is used. Specify a number between &#x60;1.0&#x60; and &#x60;10.0&#x60;. * External vulnerability ID contains: &#x60;externalVulnerabilityIdContains(\&quot;id-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. Maximum value length is 48 characters. * External vulnerability ID: &#x60;externalVulnerabilityId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * CVE ID: &#x60;cveId(\&quot;id\&quot;)&#x60;. * Risk assessment &#x60;riskAssessment(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60; Possible values are &#x60;EXPOSED&#x60;, &#x60;SENSITIVE&#x60;, &#x60;EXPLOIT&#x60;, &#x60;VULNERABLE_FUNCTION_IN_USE&#x60; and &#x60;ACCURACY_REDUCED&#x60;. * Related host ID: &#x60;relatedHostIds(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Related host name: &#x60;relatedHostNames(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Values are case-sensitive. * Related host name contains: &#x60;relatedHostNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Related Kubernetes cluster ID: &#x60;relatedKubernetesClusterIds(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Related Kubernetes cluster name: &#x60;relatedKubernetesClusterNames(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Values are case-sensitive. * Related Kubernetes cluster name contains: &#x60;relatedKubernetesClusterNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Related Kubernetes workload ID: &#x60;relatedKubernetesWorkloadIds(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Related Kubernetes workload name: &#x60;relatedKubernetesWorkloadNames(\&quot;value-1\&quot;, \&quot;value-2\&quot;)&#x60;. Values are case-sensitive. * Related Kubernetes workload name contains: &#x60;relatedKubernetesWorkloadNameContains(\&quot;value-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Management zone ID: &#x60;managementZoneIds(\&quot;mzId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;. * Management zone name: &#x60;managementZones(\&quot;name-1\&quot;, \&quot;name-2\&quot;)&#x60;. Values are case-sensitive. * Affected process group instance ID: &#x60;affectedPgiIds(\&quot;pgiId-1\&quot;, \&quot;pgiId-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Affected process group ID: &#x60;affectedPgIds(\&quot;pgId-1\&quot;, \&quot;pgId-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Affected process group name: &#x60;affectedPgNames(\&quot;name-1\&quot;, \&quot;name-2\&quot;)&#x60;. Values are case-sensitive. * Affected process group name contains: &#x60;affectedPgNameContains(\&quot;name-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Vulnerable component ID: &#x60;vulnerableComponentIds(\&quot;componentId-1\&quot;, \&quot;componentId-2\&quot;)&#x60;. Specify component IDs here. * Vulnerable component name: &#x60;vulnerableComponentNames(\&quot;name-1\&quot;, \&quot;name-2\&quot;)&#x60;. Values are case-sensitive. * Vulnerable component name contains: &#x60;vulnerableComponentNameContains(\&quot;name-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. * Host tags: &#x60;hostTags(\&quot;hostTag-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. Maximum value length is 48 characters. * Process group tags: &#x60;pgTags(\&quot;pgTag-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. Maximum value length is 48 characters. * Process group instance tags: &#x60;pgiTags(\&quot;pgiTag-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. Maximum value length is 48 characters. * Tags: &#x60;tags(\&quot;tag-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used. This selector picks hosts, process groups, and process group instances at the same time. Maximum value length is 48 characters. * Display ID: &#x60;displayIds(\&quot;S-1234\&quot;, \&quot;S-5678\&quot;)&#x60;. The &#x60;EQUALS&#x60; operator is used. * Security problem ID: &#x60;securityProblemIds(\&quot;12544152654387159360\&quot;, \&quot;5904857564184044850\&quot;)&#x60;. The &#x60;EQUALS&#x60; operator is used. * Technology: &#x60;technology(\&quot;technology-1\&quot;, \&quot;technology-2\&quot;)&#x60;. Find the possible values in the description of the **technology** field of the response. The &#x60;EQUALS&#x60; operator is used. * Vulnerability type: &#x60;vulnerabilityType(\&quot;type-1\&quot;, \&quot;type-2\&quot;)&#x60;. Possible values are &#x60;THIRD_PARTY&#x60;, &#x60;CODE_LEVEL&#x60;, &#x60;RUNTIME&#x60;.  Risk score and risk category are mutually exclusive (cannot be used at the same time).  To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.  Specify the value of a criterion as a quoted string. The following special characters must be escaped with a tilde (&#x60;~&#x60;) inside quotes: * Tilde &#x60;~&#x60;  * Quote &#x60;\&quot;&#x60;
func (r ApiGetSecurityProblemsRequest) SecurityProblemSelector(securityProblemSelector string) ApiGetSecurityProblemsRequest {
	r.securityProblemSelector = &securityProblemSelector
	return r
}

// Specifies one or more fields for sorting the security problem list. Multiple fields can be concatenated using a comma (&#x60;,&#x60;) as a separator (e.g. &#x60;+status,-timestamp&#x60;).  You can sort by the following properties with a sign prefix for the sorting order.   * &#x60;status&#x60;: The security problem status (&#x60;+&#x60; open first or &#x60;-&#x60; resolved first)  * &#x60;muted&#x60;: The security problem mute state (&#x60;+&#x60; unmuted first or &#x60;-&#x60; muted first)  * &#x60;technology&#x60;: The security problem technology  * &#x60;firstSeenTimestamp&#x60;: The timestamp of the first occurrence of the security problem (&#x60;+&#x60; new problems first or &#x60;-&#x60; old problems first)  * &#x60;lastUpdatedTimestamp&#x60;: The timestamp of the last update of the security problem (&#x60;+&#x60; recently updated problems first or &#x60;-&#x60;  earlier updated problems first) * &#x60;securityProblemId&#x60;: The auto-generated ID of the security problem (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;externalVulnerabilityId&#x60;: The ID of the external vulnerability (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;displayId&#x60;: The display ID (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;riskAssessment.riskScore&#x60;: The Davis security score (&#x60;+&#x60; lower score first or &#x60;-&#x60; higher score first)  * &#x60;riskAssessment.riskLevel&#x60;: The Davis security level (&#x60;+&#x60; lower level first or &#x60;-&#x60; higher level first)  * &#x60;riskAssessment.exposure&#x60;: Whether the problem is exposed to the internet  * &#x60;riskAssessment.dataAssets&#x60;: Whether data assets are affected  * &#x60;riskAssessment.vulnerableFunctionUsage&#x60;: Whether vulnerable functions are used  * &#x60;riskAssessment.assessmentAccuracy&#x60;: The assessments accuracy (&#x60;+&#x60; less accuracy first or &#x60;-&#x60; more accuracy first)  * &#x60;globalCounts.affectedNodes&#x60;: Number of affected nodes (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;globalCounts.affectedProcessGroupInstances&#x60;: Number of affected process group instances (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;globalCounts.affectedProcessGroups&#x60;: Number of affected process groups (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;globalCounts.exposedProcessGroups&#x60;: Number of exposed process groups (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;globalCounts.reachableDataAssets&#x60;: Number of reachable data assets (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;globalCounts.relatedApplications&#x60;: Number of related applications (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;globalCounts.relatedAttacks&#x60;: Number of attacks on the security problem (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;globalCounts.relatedHosts&#x60;: Number of related hosts (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;globalCounts.relatedKubernetesClusters&#x60;: Number of related Kubernetes cluster (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;globalCounts.relatedKubernetesWorkloads&#x60;: Number of related Kubernetes workloads (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;globalCounts.relatedServices&#x60;: Number of related services (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)  * &#x60;globalCounts.vulnerableComponents&#x60;: Number of vulnerable components (&#x60;+&#x60; lower number first or &#x60;-&#x60; higher number first)   If no prefix is set, &#x60;+&#x60; is used.
func (r ApiGetSecurityProblemsRequest) Sort(sort string) ApiGetSecurityProblemsRequest {
	r.sort = &sort
	return r
}

// A list of additional security problem properties you can add to the response.  The following properties are available (all other properties are always included and you can&#39;t remove them from the response):  * &#x60;riskAssessment&#x60;: A risk assessment of the security problem. * &#x60;managementZones&#x60;: The management zone where the security problem occurred. * &#x60;codeLevelVulnerabilityDetails&#x60;: Details of the code-level vulnerability. * &#x60;globalCounts&#x60;: Globally calculated statistics about the security problem. No management zone information is taken into account.  To add properties, specify them in a comma-separated list and prefix each property with a plus (for example, &#x60;+riskAssessment,+managementZones&#x60;). 
func (r ApiGetSecurityProblemsRequest) Fields(fields string) ApiGetSecurityProblemsRequest {
	r.fields = &fields
	return r
}

// The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of thirty days is used (&#x60;now-30d&#x60;).
func (r ApiGetSecurityProblemsRequest) From(from string) ApiGetSecurityProblemsRequest {
	r.from = &from
	return r
}

// The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used.  The end of the timeframe must not be older than 365 days.
func (r ApiGetSecurityProblemsRequest) To(to string) ApiGetSecurityProblemsRequest {
	r.to = &to
	return r
}

func (r ApiGetSecurityProblemsRequest) Execute() (*SecurityProblemList, *http.Response, error) {
	return r.ApiService.GetSecurityProblemsExecute(r)
}

/*
GetSecurityProblems Lists all security problems

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSecurityProblemsRequest
*/
func (a *SecurityProblemsAPIService) GetSecurityProblems(ctx context.Context) ApiGetSecurityProblemsRequest {
	return ApiGetSecurityProblemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecurityProblemList
func (a *SecurityProblemsAPIService) GetSecurityProblemsExecute(r ApiGetSecurityProblemsRequest) (*SecurityProblemList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityProblemList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.GetSecurityProblems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nextPageKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nextPageKey", r.nextPageKey, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.securityProblemSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "securityProblemSelector", r.securityProblemSelector, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVulnerableFunctionsRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	id string
	vulnerableFunctionsSelector *string
	groupBy *string
}

// Defines the scope of the query. Only vulnerable functions matching the specified criteria are included in the response.  You can add the following criteria. Values are *not* case sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.  * Management zone ID: &#x60;managementZoneIds(\&quot;mzId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;. * Management zone name: &#x60;managementZones(\&quot;name-1\&quot;, \&quot;name-2\&quot;)&#x60;. Values are case sensitive. * Process group ID: &#x60;processGroupIds(\&quot;pgId-1\&quot;, \&quot;pgId-2\&quot;)&#x60;. Specify Dynatrace entity IDs here. * Process group name: &#x60;processGroupNames(\&quot;name-1\&quot;, \&quot;name-2\&quot;)&#x60;. Values are case sensitive. * Process group name contains: &#x60;processGroupNameContains(\&quot;name-1\&quot;)&#x60;. The &#x60;CONTAINS&#x60; operator is used.  Specify the value of a criterion as a quoted string. The following special characters must be escaped with a tilde (&#x60;~&#x60;) inside quotes: * Tilde &#x60;~&#x60;  * Quote &#x60;\&quot;&#x60;
func (r ApiGetVulnerableFunctionsRequest) VulnerableFunctionsSelector(vulnerableFunctionsSelector string) ApiGetVulnerableFunctionsRequest {
	r.vulnerableFunctionsSelector = &vulnerableFunctionsSelector
	return r
}

// Defines additional grouping types in which vulnerable functions should be displayed.  You can add one of the following grouping types.  * Process group: &#x60;PROCESS_GROUP&#x60;
func (r ApiGetVulnerableFunctionsRequest) GroupBy(groupBy string) ApiGetVulnerableFunctionsRequest {
	r.groupBy = &groupBy
	return r
}

func (r ApiGetVulnerableFunctionsRequest) Execute() (*VulnerableFunctionsContainer, *http.Response, error) {
	return r.ApiService.GetVulnerableFunctionsExecute(r)
}

/*
GetVulnerableFunctions Lists all vulnerable functions and their usage for a third-party security problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the required third-party security problem.
 @return ApiGetVulnerableFunctionsRequest
*/
func (a *SecurityProblemsAPIService) GetVulnerableFunctions(ctx context.Context, id string) ApiGetVulnerableFunctionsRequest {
	return ApiGetVulnerableFunctionsRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return VulnerableFunctionsContainer
func (a *SecurityProblemsAPIService) GetVulnerableFunctionsExecute(r ApiGetVulnerableFunctionsRequest) (*VulnerableFunctionsContainer, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *VulnerableFunctionsContainer
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.GetVulnerableFunctions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/{id}/vulnerableFunctions"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.vulnerableFunctionsSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "vulnerableFunctionsSelector", r.vulnerableFunctionsSelector, "")
	}
	if r.groupBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupBy", r.groupBy, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMuteSecurityProblemRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	id string
	securityProblemMute *SecurityProblemMute
}

// The JSON body of the request. Contains the muting information.
func (r ApiMuteSecurityProblemRequest) SecurityProblemMute(securityProblemMute SecurityProblemMute) ApiMuteSecurityProblemRequest {
	r.securityProblemMute = &securityProblemMute
	return r
}

func (r ApiMuteSecurityProblemRequest) Execute() (*http.Response, error) {
	return r.ApiService.MuteSecurityProblemExecute(r)
}

/*
MuteSecurityProblem Mutes a security problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the required security problem.
 @return ApiMuteSecurityProblemRequest
*/
func (a *SecurityProblemsAPIService) MuteSecurityProblem(ctx context.Context, id string) ApiMuteSecurityProblemRequest {
	return ApiMuteSecurityProblemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SecurityProblemsAPIService) MuteSecurityProblemExecute(r ApiMuteSecurityProblemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.MuteSecurityProblem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/{id}/mute"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.securityProblemMute
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetRemediationItemMuteStateRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	id string
	remediationItemId string
	remediationItemMuteStateChange *RemediationItemMuteStateChange
}

// The JSON body of the request. Contains the mute state information to be applied.
func (r ApiSetRemediationItemMuteStateRequest) RemediationItemMuteStateChange(remediationItemMuteStateChange RemediationItemMuteStateChange) ApiSetRemediationItemMuteStateRequest {
	r.remediationItemMuteStateChange = &remediationItemMuteStateChange
	return r
}

func (r ApiSetRemediationItemMuteStateRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetRemediationItemMuteStateExecute(r)
}

/*
SetRemediationItemMuteState Sets the mute state of a remediation item

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the required third-party security problem.
 @param remediationItemId The ID of the remediation item.
 @return ApiSetRemediationItemMuteStateRequest
*/
func (a *SecurityProblemsAPIService) SetRemediationItemMuteState(ctx context.Context, id string, remediationItemId string) ApiSetRemediationItemMuteStateRequest {
	return ApiSetRemediationItemMuteStateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		remediationItemId: remediationItemId,
	}
}

// Execute executes the request
func (a *SecurityProblemsAPIService) SetRemediationItemMuteStateExecute(r ApiSetRemediationItemMuteStateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.SetRemediationItemMuteState")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/{id}/remediationItems/{remediationItemId}/muteState"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"remediationItemId"+"}", url.PathEscape(parameterValueToString(r.remediationItemId, "remediationItemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.remediationItemMuteStateChange
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUnmuteSecurityProblemRequest struct {
	ctx context.Context
	ApiService *SecurityProblemsAPIService
	id string
	securityProblemUnmute *SecurityProblemUnmute
}

// The JSON body of the request. Contains the un-muting information.
func (r ApiUnmuteSecurityProblemRequest) SecurityProblemUnmute(securityProblemUnmute SecurityProblemUnmute) ApiUnmuteSecurityProblemRequest {
	r.securityProblemUnmute = &securityProblemUnmute
	return r
}

func (r ApiUnmuteSecurityProblemRequest) Execute() (*http.Response, error) {
	return r.ApiService.UnmuteSecurityProblemExecute(r)
}

/*
UnmuteSecurityProblem Un-mutes a security problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id The ID of the required security problem.
 @return ApiUnmuteSecurityProblemRequest
*/
func (a *SecurityProblemsAPIService) UnmuteSecurityProblem(ctx context.Context, id string) ApiUnmuteSecurityProblemRequest {
	return ApiUnmuteSecurityProblemRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *SecurityProblemsAPIService) UnmuteSecurityProblemExecute(r ApiUnmuteSecurityProblemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityProblemsAPIService.UnmuteSecurityProblem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/securityProblems/{id}/unmute"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.securityProblemUnmute
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
