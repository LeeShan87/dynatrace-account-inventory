/*
Dynatrace Environment API

 Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package environmentv2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ProblemsAPIService ProblemsAPI service
type ProblemsAPIService service

type ApiCloseProblemRequest struct {
	ctx context.Context
	ApiService *ProblemsAPIService
	problemId string
	problemCloseRequestDtoImpl *ProblemCloseRequestDtoImpl
}

// The JSON body of the request. Contains the closing comment on the problem.
func (r ApiCloseProblemRequest) ProblemCloseRequestDtoImpl(problemCloseRequestDtoImpl ProblemCloseRequestDtoImpl) ApiCloseProblemRequest {
	r.problemCloseRequestDtoImpl = &problemCloseRequestDtoImpl
	return r
}

func (r ApiCloseProblemRequest) Execute() (*ProblemCloseResult, *http.Response, error) {
	return r.ApiService.CloseProblemExecute(r)
}

/*
CloseProblem Closes the specified problem and adds a closing comment on it

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param problemId The ID of the required problem.
 @return ApiCloseProblemRequest
*/
func (a *ProblemsAPIService) CloseProblem(ctx context.Context, problemId string) ApiCloseProblemRequest {
	return ApiCloseProblemRequest{
		ApiService: a,
		ctx: ctx,
		problemId: problemId,
	}
}

// Execute executes the request
//  @return ProblemCloseResult
func (a *ProblemsAPIService) CloseProblemExecute(r ApiCloseProblemRequest) (*ProblemCloseResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ProblemCloseResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProblemsAPIService.CloseProblem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/problems/{problemId}/close"
	localVarPath = strings.Replace(localVarPath, "{"+"problemId"+"}", url.PathEscape(parameterValueToString(r.problemId, "problemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.problemCloseRequestDtoImpl
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateCommentRequest struct {
	ctx context.Context
	ApiService *ProblemsAPIService
	problemId string
	commentRequestDtoImpl *CommentRequestDtoImpl
}

// The JSON body of the request. Contains the comment to be added.
func (r ApiCreateCommentRequest) CommentRequestDtoImpl(commentRequestDtoImpl CommentRequestDtoImpl) ApiCreateCommentRequest {
	r.commentRequestDtoImpl = &commentRequestDtoImpl
	return r
}

func (r ApiCreateCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateCommentExecute(r)
}

/*
CreateComment Adds a new comment on the specified problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param problemId The ID of the required problem.
 @return ApiCreateCommentRequest
*/
func (a *ProblemsAPIService) CreateComment(ctx context.Context, problemId string) ApiCreateCommentRequest {
	return ApiCreateCommentRequest{
		ApiService: a,
		ctx: ctx,
		problemId: problemId,
	}
}

// Execute executes the request
func (a *ProblemsAPIService) CreateCommentExecute(r ApiCreateCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProblemsAPIService.CreateComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/problems/{problemId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"problemId"+"}", url.PathEscape(parameterValueToString(r.problemId, "problemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.commentRequestDtoImpl
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteCommentRequest struct {
	ctx context.Context
	ApiService *ProblemsAPIService
	problemId string
	commentId string
}

func (r ApiDeleteCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCommentExecute(r)
}

/*
DeleteComment Deletes the specified comment from a problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param problemId The ID of the required problem.
 @param commentId The ID of the required comment.
 @return ApiDeleteCommentRequest
*/
func (a *ProblemsAPIService) DeleteComment(ctx context.Context, problemId string, commentId string) ApiDeleteCommentRequest {
	return ApiDeleteCommentRequest{
		ApiService: a,
		ctx: ctx,
		problemId: problemId,
		commentId: commentId,
	}
}

// Execute executes the request
func (a *ProblemsAPIService) DeleteCommentExecute(r ApiDeleteCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProblemsAPIService.DeleteComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/problems/{problemId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"problemId"+"}", url.PathEscape(parameterValueToString(r.problemId, "problemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetCommentRequest struct {
	ctx context.Context
	ApiService *ProblemsAPIService
	problemId string
	commentId string
}

func (r ApiGetCommentRequest) Execute() (*Comment, *http.Response, error) {
	return r.ApiService.GetCommentExecute(r)
}

/*
GetComment Gets the specified comment on a problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param problemId The ID of the required problem.
 @param commentId The ID of the required comment.
 @return ApiGetCommentRequest
*/
func (a *ProblemsAPIService) GetComment(ctx context.Context, problemId string, commentId string) ApiGetCommentRequest {
	return ApiGetCommentRequest{
		ApiService: a,
		ctx: ctx,
		problemId: problemId,
		commentId: commentId,
	}
}

// Execute executes the request
//  @return Comment
func (a *ProblemsAPIService) GetCommentExecute(r ApiGetCommentRequest) (*Comment, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Comment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProblemsAPIService.GetComment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/problems/{problemId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"problemId"+"}", url.PathEscape(parameterValueToString(r.problemId, "problemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCommentsRequest struct {
	ctx context.Context
	ApiService *ProblemsAPIService
	problemId string
	nextPageKey *string
	pageSize *int64
}

// The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.  
func (r ApiGetCommentsRequest) NextPageKey(nextPageKey string) ApiGetCommentsRequest {
	r.nextPageKey = &nextPageKey
	return r
}

// The amount of comments in a single response payload.   The maximal allowed page size is 500.   If not set, 10 is used.
func (r ApiGetCommentsRequest) PageSize(pageSize int64) ApiGetCommentsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetCommentsRequest) Execute() (*CommentsList, *http.Response, error) {
	return r.ApiService.GetCommentsExecute(r)
}

/*
GetComments Gets all comments on the specified problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param problemId The ID of the required problem.
 @return ApiGetCommentsRequest
*/
func (a *ProblemsAPIService) GetComments(ctx context.Context, problemId string) ApiGetCommentsRequest {
	return ApiGetCommentsRequest{
		ApiService: a,
		ctx: ctx,
		problemId: problemId,
	}
}

// Execute executes the request
//  @return CommentsList
func (a *ProblemsAPIService) GetCommentsExecute(r ApiGetCommentsRequest) (*CommentsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CommentsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProblemsAPIService.GetComments")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/problems/{problemId}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"problemId"+"}", url.PathEscape(parameterValueToString(r.problemId, "problemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.nextPageKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nextPageKey", r.nextPageKey, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProblemRequest struct {
	ctx context.Context
	ApiService *ProblemsAPIService
	problemId string
	fields *string
}

// A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#39;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;).
func (r ApiGetProblemRequest) Fields(fields string) ApiGetProblemRequest {
	r.fields = &fields
	return r
}

func (r ApiGetProblemRequest) Execute() (*Problem, *http.Response, error) {
	return r.ApiService.GetProblemExecute(r)
}

/*
GetProblem Gets the properties of the specified problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param problemId The ID of the required problem.
 @return ApiGetProblemRequest
*/
func (a *ProblemsAPIService) GetProblem(ctx context.Context, problemId string) ApiGetProblemRequest {
	return ApiGetProblemRequest{
		ApiService: a,
		ctx: ctx,
		problemId: problemId,
	}
}

// Execute executes the request
//  @return Problem
func (a *ProblemsAPIService) GetProblemExecute(r ApiGetProblemRequest) (*Problem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Problem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProblemsAPIService.GetProblem")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/problems/{problemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"problemId"+"}", url.PathEscape(parameterValueToString(r.problemId, "problemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProblemsRequest struct {
	ctx context.Context
	ApiService *ProblemsAPIService
	fields *string
	nextPageKey *string
	pageSize *int64
	from *string
	to *string
	problemSelector *string
	entitySelector *string
	sort *string
}

// A list of additional problem properties you can add to the response.   The following properties are available (all other properties are always included and you can&#39;t remove them from the response):   * &#x60;evidenceDetails&#x60;: The details of the root cause. * &#x60;impactAnalysis&#x60;: The impact analysis of the problem on other entities/users. * &#x60;recentComments&#x60;: A list of the most recent comments to the problem.  To add properties, specify them as a comma-separated list (for example, &#x60;evidenceDetails,impactAnalysis&#x60;).   The field is valid only for the current page of results. You must set it for each page you&#39;re requesting.
func (r ApiGetProblemsRequest) Fields(fields string) ApiGetProblemsRequest {
	r.fields = &fields
	return r
}

// The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters except the optional **fields** parameter.  
func (r ApiGetProblemsRequest) NextPageKey(nextPageKey string) ApiGetProblemsRequest {
	r.nextPageKey = &nextPageKey
	return r
}

// The amount of problems in a single response payload.   The maximal allowed page size is 500.   If not set, 50 is used.
func (r ApiGetProblemsRequest) PageSize(pageSize int64) ApiGetProblemsRequest {
	r.pageSize = &pageSize
	return r
}

// The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two hours is used (&#x60;now-2h&#x60;).
func (r ApiGetProblemsRequest) From(from string) ApiGetProblemsRequest {
	r.from = &from
	return r
}

// The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used.
func (r ApiGetProblemsRequest) To(to string) ApiGetProblemsRequest {
	r.to = &to
	return r
}

// Defines the scope of the query. Only problems matching the specified criteria are included into response.   You can add one or several of the criteria listed below. For each criterion you can specify multiple comma-separated values, unless stated otherwise. If several values are specified, the **OR** logic applies. All values must be quoted.  * Status: &#x60;status(\&quot;open\&quot;)&#x60; or &#x60;status(\&quot;closed\&quot;)&#x60;. You can specify only one status.  * Severity level: &#x60;severityLevel(\&quot;level-1\&quot;,\&quot;level-2\&quot;)&#x60;. Find the possible values in the description of the **severityLevel** field of the response. * Impact level: &#x60;impactLevel(\&quot;level-11\&quot;,\&quot;level-2\&quot;)&#x60; Find the possible values in the description of the **impactLevel** field of the response. * Root cause entity: &#x60;rootCauseEntity(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Management zone ID: &#x60;managementZoneIds(\&quot;mZId-1\&quot;, \&quot;mzId-2\&quot;)&#x60;.  * Management zone name: &#x60;managementZones(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Impacted entities: &#x60;impactedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Affected entities: &#x60;affectedEntities(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Type of affected entities: &#x60;affectedEntityTypes(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Problem ID: &#x60;problemId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile ID: &#x60;problemFilterIds(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Alerting profile name (contains, case-insensitive): &#x60;problemFilterNames(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Alerting profile name (exact match, case-insensitive): &#x60;problemFilterNames.equals(\&quot;value-1\&quot;,\&quot;value-2\&quot;)&#x60;.  * Entity tags: &#x60;entityTags(\&quot;[context]key:value\&quot;,\&quot;key:value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. If a value-only tag has a colon (&#x60;:&#x60;) in it, you must escape the colon with a backslash(&#x60;\\&#x60;). Otherwise, the tag will be parsed as a &#x60;key:value tag&#x60;. All tag values are case-sensitive. * Display ID of the problem: &#x60;displayId(\&quot;id-1\&quot;, \&quot;id-2\&quot;)&#x60;.  * Under maintenance: &#x60;underMaintenance(true|false)&#x60;. Shows (true) or hides (false) all problems created during maintenance mode. * Text search: &#x60;text(\&quot;value\&quot;)&#x60;. Text search on the following fields: problem title, event titles, displayId and the id of affected and impacted entities. The text search is case insensitive, partial matching and based on a relevance score. Therefore the &#x60;relevance&#x60; sort option should be used to get the most relevant problems first. The special characters &#x60;~&#x60; and &#x60;\&quot;&#x60; need to be escaped using a &#x60;~&#x60; (e.g. double quote search &#x60;text(\&quot;~\&quot;\&quot;)&#x60;). The search value is limited to 30 characters.  To set several criteria, separate them with a comma (&#x60;,&#x60;). Only results matching **all** criteria are included in the response.   
func (r ApiGetProblemsRequest) ProblemSelector(problemSelector string) ApiGetProblemsRequest {
	r.problemSelector = &problemSelector
	return r
}

// The entity scope of the query. You must set one of these criteria:   * Entity type: &#x60;type(\&quot;TYPE\&quot;)&#x60;  * Dynatrace entity ID: &#x60;entityId(\&quot;id\&quot;)&#x60;. You can specify several IDs, separated by a comma (&#x60;entityId(\&quot;id-1\&quot;,\&quot;id-2\&quot;)&#x60;). All requested entities must be of the same type.   You can add one or more of the following criteria. Values are case-sensitive and the &#x60;EQUALS&#x60; operator is used unless otherwise specified.   * Tag: &#x60;tag(\&quot;value\&quot;)&#x60;. Tags in &#x60;[context]key:value&#x60;, &#x60;key:value&#x60;, and &#x60;value&#x60; formats are detected and parsed automatically. Any colons (&#x60;:&#x60;) that are part of the key or value must be escaped with a backslash(&#x60;\\&#x60;). Otherwise, it will be interpreted as the separator between the key and the value. All tag values are case-sensitive.  * Management zone ID: &#x60;mzId(123)&#x60;  * Management zone name: &#x60;mzName(\&quot;value\&quot;)&#x60; * Entity name:   * &#x60;entityName.equals&#x60;: performs a non-casesensitive &#x60;EQUALS&#x60; query.   * &#x60;entityName.startsWith&#x60;: changes the operator to &#x60;BEGINS WITH&#x60;.   * &#x60;entityName.in&#x60;: enables you to provide multiple values. The &#x60;EQUALS&#x60; operator applies.   * &#x60;caseSensitive(entityName.equals(\&quot;value\&quot;))&#x60;: takes any entity name criterion as an argument and makes the value case-sensitive. * Health state (HEALTHY,UNHEALTHY): &#x60;healthState(\&quot;HEALTHY\&quot;)&#x60; * First seen timestamp: &#x60;firstSeenTms.&lt;operator&gt;(now-3h)&#x60;. Use any timestamp format from the **from**_/_**to** parameters.   The following operators are available:  * &#x60;lte&#x60;: earlier than or at the specified time  * &#x60;lt&#x60;: earlier than the specified time  * &#x60;gte&#x60;: later than or at the specified time  * &#x60;gt&#x60;: later than the specified time * Entity attribute: &#x60;&lt;attribute&gt;(\&quot;value1\&quot;,\&quot;value2\&quot;)&#x60; and &#x60;&lt;attribute&gt;.exists()&#x60;. To fetch the list of available attributes, execute the [GET entity type](https://dt-url.net/2ka3ivt) request and check the **properties** field of the response.  * Relationships: &#x60;fromRelationships.&lt;relationshipName&gt;()&#x60; and &#x60;toRelationships.&lt;relationshipName&gt;()&#x60;. This criterion takes an entity selector as an attribute. To fetch the list of available relationships, execute the [GET entity type](https://dt-url.net/2ka3ivt) request and check the **fromRelationships** and **toRelationships** fields. * Negation: &#x60;not(&lt;criterion&gt;)&#x60;. Inverts any criterion except for **type**.   For more information, see [Entity selector](https://dt-url.net/apientityselector) in Dynatrace Documentation.   To set several criteria, separate them with a comma (&#x60;,&#x60;). For example, &#x60;type(\&quot;HOST\&quot;),healthState(\&quot;HEALTHY\&quot;)&#x60;. Only results matching **all** criteria are included in the response.   The maximum string length is 2,000 characters.   The maximum number of entities that may be selected is limited to 10000.  
func (r ApiGetProblemsRequest) EntitySelector(entitySelector string) ApiGetProblemsRequest {
	r.entitySelector = &entitySelector
	return r
}

// Specifies a set of comma-separated (&#x60;,&#x60;) fields for sorting in the problem list.  You can sort by the following properties with a sign prefix for the sorting order.    * &#x60;status&#x60;: problem status (&#x60;+&#x60; open problems first or &#x60;-&#x60; closed problems first)  * &#x60;startTime&#x60;: problem start time (&#x60;+&#x60; old problems first or &#x60;-&#x60; new problems first)   * &#x60;relevance&#x60;: problem relevance (&#x60;+&#x60; least relevant problems first or &#x60;-&#x60; most relevant problems first) - can be used only in combination with text search   If no prefix is set, &#x60;+&#x60; is used.   You can specify several levels of sorting. For example, &#x60;+status,-startTime&#x60; sorts problems by status, open problems first. Within the status, problems are sorted by start time, oldest first.
func (r ApiGetProblemsRequest) Sort(sort string) ApiGetProblemsRequest {
	r.sort = &sort
	return r
}

func (r ApiGetProblemsRequest) Execute() (*Problems, *http.Response, error) {
	return r.ApiService.GetProblemsExecute(r)
}

/*
GetProblems Lists problems observed within the specified timeframe

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProblemsRequest
*/
func (a *ProblemsAPIService) GetProblems(ctx context.Context) ApiGetProblemsRequest {
	return ApiGetProblemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Problems
func (a *ProblemsAPIService) GetProblemsExecute(r ApiGetProblemsRequest) (*Problems, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Problems
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProblemsAPIService.GetProblems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/problems"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.nextPageKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nextPageKey", r.nextPageKey, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	if r.problemSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "problemSelector", r.problemSelector, "")
	}
	if r.entitySelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "entitySelector", r.entitySelector, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateCommentRequest struct {
	ctx context.Context
	ApiService *ProblemsAPIService
	problemId string
	commentId string
	commentRequestDtoImpl *CommentRequestDtoImpl
}

// The JSON body of the request. Contains the updated comment.
func (r ApiUpdateCommentRequest) CommentRequestDtoImpl(commentRequestDtoImpl CommentRequestDtoImpl) ApiUpdateCommentRequest {
	r.commentRequestDtoImpl = &commentRequestDtoImpl
	return r
}

func (r ApiUpdateCommentRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateCommentExecute(r)
}

/*
UpdateComment Updates the specified comment on a problem

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param problemId The ID of the required problem.
 @param commentId The ID of the required comment.
 @return ApiUpdateCommentRequest
*/
func (a *ProblemsAPIService) UpdateComment(ctx context.Context, problemId string, commentId string) ApiUpdateCommentRequest {
	return ApiUpdateCommentRequest{
		ApiService: a,
		ctx: ctx,
		problemId: problemId,
		commentId: commentId,
	}
}

// Execute executes the request
func (a *ProblemsAPIService) UpdateCommentExecute(r ApiUpdateCommentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ProblemsAPIService.UpdateComment")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/problems/{problemId}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"problemId"+"}", url.PathEscape(parameterValueToString(r.problemId, "problemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", url.PathEscape(parameterValueToString(r.commentId, "commentId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.commentRequestDtoImpl
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
