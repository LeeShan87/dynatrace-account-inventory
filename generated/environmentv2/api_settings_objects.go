/*
Dynatrace Environment API

 Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package environmentv2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// SettingsObjectsAPIService SettingsObjectsAPI service
type SettingsObjectsAPIService service

type ApiDeleteSettingsObjectByObjectIdRequest struct {
	ctx context.Context
	ApiService *SettingsObjectsAPIService
	objectId string
	updateToken *string
}

// The update token of the object. You can use it to detect simultaneous modifications by different users.   It is generated upon retrieval (GET requests). If set on update (PUT request) or deletion, the update/deletion will be allowed only if there wasn&#39;t any change between the retrieval and the update.   If omitted on update/deletion, the operation overrides the current value or deletes it without any checks.
func (r ApiDeleteSettingsObjectByObjectIdRequest) UpdateToken(updateToken string) ApiDeleteSettingsObjectByObjectIdRequest {
	r.updateToken = &updateToken
	return r
}

func (r ApiDeleteSettingsObjectByObjectIdRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSettingsObjectByObjectIdExecute(r)
}

/*
DeleteSettingsObjectByObjectId Deletes the specified settings object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The ID of the required settings object.
 @return ApiDeleteSettingsObjectByObjectIdRequest
*/
func (a *SettingsObjectsAPIService) DeleteSettingsObjectByObjectId(ctx context.Context, objectId string) ApiDeleteSettingsObjectByObjectIdRequest {
	return ApiDeleteSettingsObjectByObjectIdRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
func (a *SettingsObjectsAPIService) DeleteSettingsObjectByObjectIdExecute(r ApiDeleteSettingsObjectByObjectIdRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsObjectsAPIService.DeleteSettingsObjectByObjectId")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/objects/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.updateToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateToken", r.updateToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SettingsObjectResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v SettingsObjectResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v SettingsObjectResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetEffectiveSettingsValuesRequest struct {
	ctx context.Context
	ApiService *SettingsObjectsAPIService
	schemaIds *string
	scope *string
	fields *string
	nextPageKey *string
	pageSize *int64
}

// A list of comma-separated schema IDs to which the requested objects belong.   Only considered on load of the first page, when the **nextPageKey** is not set.
func (r ApiGetEffectiveSettingsValuesRequest) SchemaIds(schemaIds string) ApiGetEffectiveSettingsValuesRequest {
	r.schemaIds = &schemaIds
	return r
}

// The scope that the requested objects target.   The selection only matches objects directly targeting the specified scope. For example, &#x60;environment&#x60; will not match objects that target a host within environment. For more details, please see [Dynatrace Documentation](https://dt-url.net/ky03459).   To load the first page, when the **nextPageKey** is not set, this parameter is required. 
func (r ApiGetEffectiveSettingsValuesRequest) Scope(scope string) ApiGetEffectiveSettingsValuesRequest {
	r.scope = &scope
	return r
}

// A list of fields to be included to the response. The provided set of fields replaces the default set.    Specify the required top-level fields, separated by commas (for example, &#x60;origin,value&#x60;).  Supported fields: &#x60;summary&#x60;, &#x60;searchSummary&#x60;, &#x60;created&#x60;, &#x60;modified&#x60;, &#x60;createdBy&#x60;, &#x60;modifiedBy&#x60;, &#x60;author&#x60;, &#x60;origin&#x60;, &#x60;schemaId&#x60;, &#x60;schemaVersion&#x60;, &#x60;value&#x60;, &#x60;externalId&#x60;.
func (r ApiGetEffectiveSettingsValuesRequest) Fields(fields string) ApiGetEffectiveSettingsValuesRequest {
	r.fields = &fields
	return r
}

// The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters. 
func (r ApiGetEffectiveSettingsValuesRequest) NextPageKey(nextPageKey string) ApiGetEffectiveSettingsValuesRequest {
	r.nextPageKey = &nextPageKey
	return r
}

// The amount of settings objects in a single response payload.   The maximal allowed page size is 500.   If not set, 100 is used.
func (r ApiGetEffectiveSettingsValuesRequest) PageSize(pageSize int64) ApiGetEffectiveSettingsValuesRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetEffectiveSettingsValuesRequest) Execute() (*EffectiveSettingsValuesList, *http.Response, error) {
	return r.ApiService.GetEffectiveSettingsValuesExecute(r)
}

/*
GetEffectiveSettingsValues Lists effective settings values

Lists effective settings values for selected schemas at a selected scope (or entity). This operation evaluates the hierarchy of persisted objects (see [/settings/objects](#/Settings%20-%20Objects/getSettingsObjects))

It will always return a result for a schema/scope combination, even if the schema would not be relevant to the given scope/entity.

If no object along the hierarchy is persisted, the default value as defined in the schema will be returned.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetEffectiveSettingsValuesRequest
*/
func (a *SettingsObjectsAPIService) GetEffectiveSettingsValues(ctx context.Context) ApiGetEffectiveSettingsValuesRequest {
	return ApiGetEffectiveSettingsValuesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EffectiveSettingsValuesList
func (a *SettingsObjectsAPIService) GetEffectiveSettingsValuesExecute(r ApiGetEffectiveSettingsValuesRequest) (*EffectiveSettingsValuesList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EffectiveSettingsValuesList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsObjectsAPIService.GetEffectiveSettingsValues")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/effectiveValues"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.schemaIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "schemaIds", r.schemaIds, "")
	}
	if r.scope != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scope", r.scope, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.nextPageKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nextPageKey", r.nextPageKey, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSettingsObjectByObjectIdRequest struct {
	ctx context.Context
	ApiService *SettingsObjectsAPIService
	objectId string
}

func (r ApiGetSettingsObjectByObjectIdRequest) Execute() (*SettingsObject, *http.Response, error) {
	return r.ApiService.GetSettingsObjectByObjectIdExecute(r)
}

/*
GetSettingsObjectByObjectId Gets the specified settings object

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The ID of the required settings object.
 @return ApiGetSettingsObjectByObjectIdRequest
*/
func (a *SettingsObjectsAPIService) GetSettingsObjectByObjectId(ctx context.Context, objectId string) ApiGetSettingsObjectByObjectIdRequest {
	return ApiGetSettingsObjectByObjectIdRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return SettingsObject
func (a *SettingsObjectsAPIService) GetSettingsObjectByObjectIdExecute(r ApiGetSettingsObjectByObjectIdRequest) (*SettingsObject, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SettingsObject
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsObjectsAPIService.GetSettingsObjectByObjectId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/objects/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSettingsObjectsRequest struct {
	ctx context.Context
	ApiService *SettingsObjectsAPIService
	schemaIds *string
	scopes *string
	externalIds *string
	fields *string
	nextPageKey *string
	pageSize *int64
}

// A list of comma-separated schema IDs to which the requested objects belong.   To load the first page, when the **nextPageKey** is not set, either this parameter or **scopes** is required.   To load all objects belonging to the given schema IDs leave the **scopes** parameter empty.
func (r ApiGetSettingsObjectsRequest) SchemaIds(schemaIds string) ApiGetSettingsObjectsRequest {
	r.schemaIds = &schemaIds
	return r
}

// A list of comma-separated scopes, that the requested objects target.   The selection only matches objects directly targeting the specified scopes. For example, &#x60;environment&#x60; will not match objects that target a host within environment. For more details, please see [Dynatrace Documentation](https://dt-url.net/ky03459).   To load the first page, when the **nextPageKey** is not set, either this parameter or **schemaIds** is required.   To load all objects belonging to the given scopes leave the **schemaIds** parameter empty.
func (r ApiGetSettingsObjectsRequest) Scopes(scopes string) ApiGetSettingsObjectsRequest {
	r.scopes = &scopes
	return r
}

// A list of comma-separated external IDs that the requested objects have.   Each external ID has a maximum length of 500 characters.  Only considered on load of the first page, when the **nextPageKey** is not set.
func (r ApiGetSettingsObjectsRequest) ExternalIds(externalIds string) ApiGetSettingsObjectsRequest {
	r.externalIds = &externalIds
	return r
}

// A list of fields to be included to the response. The provided set of fields replaces the default set.    Specify the required top-level fields, separated by commas (for example, &#x60;objectId,value&#x60;).  Supported fields: &#x60;objectId&#x60;, &#x60;summary&#x60;, &#x60;searchSummary&#x60;, &#x60;created&#x60;, &#x60;modified&#x60;, &#x60;createdBy&#x60;, &#x60;modifiedBy&#x60;, &#x60;author&#x60;, &#x60;updateToken&#x60;, &#x60;scope&#x60;, &#x60;modificationInfo&#x60;, &#x60;schemaId&#x60;, &#x60;schemaVersion&#x60;, &#x60;value&#x60;, &#x60;externalId&#x60;.
func (r ApiGetSettingsObjectsRequest) Fields(fields string) ApiGetSettingsObjectsRequest {
	r.fields = &fields
	return r
}

// The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters. 
func (r ApiGetSettingsObjectsRequest) NextPageKey(nextPageKey string) ApiGetSettingsObjectsRequest {
	r.nextPageKey = &nextPageKey
	return r
}

// The amount of settings objects in a single response payload.   The maximal allowed page size is 500.   If not set, 100 is used.
func (r ApiGetSettingsObjectsRequest) PageSize(pageSize int64) ApiGetSettingsObjectsRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetSettingsObjectsRequest) Execute() (*ObjectsList, *http.Response, error) {
	return r.ApiService.GetSettingsObjectsExecute(r)
}

/*
GetSettingsObjects Lists persisted settings objects

Lists persisted settings objects for selected schemas at selected scopes (or entities).

If nothing is persisted or if all persisted settings objects are not accessible due to missing permissions, no items will be returned.

To query the effective values (including schema defaults) please see [/settings/effectiveValues](#/Settings%20-%20Objects/getEffectiveSettingsValues).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSettingsObjectsRequest
*/
func (a *SettingsObjectsAPIService) GetSettingsObjects(ctx context.Context) ApiGetSettingsObjectsRequest {
	return ApiGetSettingsObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ObjectsList
func (a *SettingsObjectsAPIService) GetSettingsObjectsExecute(r ApiGetSettingsObjectsRequest) (*ObjectsList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ObjectsList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsObjectsAPIService.GetSettingsObjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/objects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.schemaIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "schemaIds", r.schemaIds, "")
	}
	if r.scopes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "scopes", r.scopes, "")
	}
	if r.externalIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalIds", r.externalIds, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.nextPageKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nextPageKey", r.nextPageKey, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostSettingsObjectsRequest struct {
	ctx context.Context
	ApiService *SettingsObjectsAPIService
	validateOnly *bool
	settingsObjectCreate *[]SettingsObjectCreate
}

// If &#x60;true&#x60;, the request runs only validation of the submitted settings objects, without saving them.
func (r ApiPostSettingsObjectsRequest) ValidateOnly(validateOnly bool) ApiPostSettingsObjectsRequest {
	r.validateOnly = &validateOnly
	return r
}

// The JSON body of the request. Contains the settings objects.
func (r ApiPostSettingsObjectsRequest) SettingsObjectCreate(settingsObjectCreate []SettingsObjectCreate) ApiPostSettingsObjectsRequest {
	r.settingsObjectCreate = &settingsObjectCreate
	return r
}

func (r ApiPostSettingsObjectsRequest) Execute() ([]SettingsObjectResponse, *http.Response, error) {
	return r.ApiService.PostSettingsObjectsExecute(r)
}

/*
PostSettingsObjects Creates a new settings object

You can upload several objects at once. In that case each object returns its own response code. Check the response body for details.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostSettingsObjectsRequest
*/
func (a *SettingsObjectsAPIService) PostSettingsObjects(ctx context.Context) ApiPostSettingsObjectsRequest {
	return ApiPostSettingsObjectsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SettingsObjectResponse
func (a *SettingsObjectsAPIService) PostSettingsObjectsExecute(r ApiPostSettingsObjectsRequest) ([]SettingsObjectResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SettingsObjectResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsObjectsAPIService.PostSettingsObjects")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/objects"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.validateOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateOnly", r.validateOnly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.settingsObjectCreate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []SettingsObjectResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []SettingsObjectResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v []SettingsObjectResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutSettingsObjectByObjectIdRequest struct {
	ctx context.Context
	ApiService *SettingsObjectsAPIService
	objectId string
	settingsObjectUpdate *SettingsObjectUpdate
}

// The JSON body of the request. Contains updated parameters of the settings object.
func (r ApiPutSettingsObjectByObjectIdRequest) SettingsObjectUpdate(settingsObjectUpdate SettingsObjectUpdate) ApiPutSettingsObjectByObjectIdRequest {
	r.settingsObjectUpdate = &settingsObjectUpdate
	return r
}

func (r ApiPutSettingsObjectByObjectIdRequest) Execute() (*SettingsObjectResponse, *http.Response, error) {
	return r.ApiService.PutSettingsObjectByObjectIdExecute(r)
}

/*
PutSettingsObjectByObjectId Updates an existing settings object

To update a property of the `secret` type you need to pass the new value unmasked. To keep the current value, send the current masked secret. You can obtain it via [GET an object](https://dt-url.net/kj036oj) endpoint. 

Some schemas don't allow passing of the masked secret. In that case you need to send the unmasked secret with every update of the object.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param objectId The ID of the required settings object.
 @return ApiPutSettingsObjectByObjectIdRequest
*/
func (a *SettingsObjectsAPIService) PutSettingsObjectByObjectId(ctx context.Context, objectId string) ApiPutSettingsObjectByObjectIdRequest {
	return ApiPutSettingsObjectByObjectIdRequest{
		ApiService: a,
		ctx: ctx,
		objectId: objectId,
	}
}

// Execute executes the request
//  @return SettingsObjectResponse
func (a *SettingsObjectsAPIService) PutSettingsObjectByObjectIdExecute(r ApiPutSettingsObjectByObjectIdRequest) (*SettingsObjectResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SettingsObjectResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SettingsObjectsAPIService.PutSettingsObjectByObjectId")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/settings/objects/{objectId}"
	localVarPath = strings.Replace(localVarPath, "{"+"objectId"+"}", url.PathEscape(parameterValueToString(r.objectId, "objectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json; charset=utf-8"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.settingsObjectUpdate
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v SettingsObjectResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v SettingsObjectResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v SettingsObjectResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
