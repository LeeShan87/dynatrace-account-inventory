/*
Dynatrace Environment API

 Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package environmentv2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ReleasesAPIService ReleasesAPI service
type ReleasesAPIService service

type ApiGetReleasesRequest struct {
	ctx context.Context
	ApiService *ReleasesAPIService
	from *string
	to *string
	nextPageKey *string
	pageSize *int64
	demo *bool
	releasesSelector *string
	sort *string
}

// The start of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the relative timeframe of two weeks is used (&#x60;now-2w&#x60;).
func (r ApiGetReleasesRequest) From(from string) ApiGetReleasesRequest {
	r.from = &from
	return r
}

// The end of the requested timeframe.   You can use one of the following formats:  * Timestamp in UTC milliseconds.  * Human-readable format of &#x60;2021-01-25T05:57:01.123+01:00&#x60;. If no time zone is specified, UTC is used. You can use a space character instead of the &#x60;T&#x60;. Seconds and fractions of a second are optional.  * Relative timeframe, back from now. The format is &#x60;now-NU/A&#x60;, where &#x60;N&#x60; is the amount of time, &#x60;U&#x60; is the unit of time, and &#x60;A&#x60; is an alignment. The alignment rounds all the smaller values to the nearest zero in the past. For example, &#x60;now-1y/w&#x60; is one year back, aligned by a week.  You can also specify relative timeframe without an alignment: &#x60;now-NU&#x60;.  Supported time units for the relative timeframe are:     * &#x60;m&#x60;: minutes     * &#x60;h&#x60;: hours     * &#x60;d&#x60;: days     * &#x60;w&#x60;: weeks     * &#x60;M&#x60;: months     * &#x60;y&#x60;: years   If not set, the current timestamp is used.
func (r ApiGetReleasesRequest) To(to string) ApiGetReleasesRequest {
	r.to = &to
	return r
}

// The cursor for the next page of results. You can find it in the **nextPageKey** field of the previous response.   The first page is always returned if you don&#39;t specify the **nextPageKey** query parameter.   When the **nextPageKey** is set to obtain subsequent pages, you must omit all other query parameters. 
func (r ApiGetReleasesRequest) NextPageKey(nextPageKey string) ApiGetReleasesRequest {
	r.nextPageKey = &nextPageKey
	return r
}

// The amount of Releases in a single response payload.   The maximal allowed page size is 1000.   If not set, 100 is used.
func (r ApiGetReleasesRequest) PageSize(pageSize int64) ApiGetReleasesRequest {
	r.pageSize = &pageSize
	return r
}

// Get your Releases (&#x60;false&#x60;) or a set of demo Releases (&#x60;true&#x60;).
func (r ApiGetReleasesRequest) Demo(demo bool) ApiGetReleasesRequest {
	r.demo = &demo
	return r
}

// Defines the scope of the query. Only Releases matching the provided criteria are included in the response.  You can add one or several of the criteria listed below. * Management zone: type(PROCESS_GROUP_INSTANCE),mzName(\&quot;ManagementZone-A\&quot;). Filters for all releases in the given management zone. The filter is case-sensitive. * Monitoring state: monitoringState(\&quot;Active\&quot;) or monitoringState(\&quot;Inactive\&quot;). You can specify only one monitoring state.  * Health state: healthState(\&quot;HEALTHY\&quot;) or healthState(\&quot;UNHEALTHY\&quot;). You can specify only one health state. * Security vulnerability: affectedBySecurityProblem(\&quot;Detected\&quot;) or affectedBySecurityProblem(\&quot;Not detected\&quot;). You can specify only one security vulnerability state. * Name: entityName(\&quot;name\&quot;). Filters for all releases that contain the given value in their name. The filter is case-insensitive. * Entity ID: entityId(\&quot;id\&quot;). * Product: releasesProduct(\&quot;product\&quot;). Filters for all releases that contain the given value in their product. The filter is case-insensitive. * Stage: releasesStage(\&quot;stage\&quot;). Filters for all releases that contain the given value in their stage. The filter is case-insensitive. * Version: releasesVersion(\&quot;version\&quot;). Filters for all releases that contain the given value in their version. The filter is case-insensitive.  To set several criteria, separate them with comma (,). Only results matching all criteria are included in the response. e.g., .../api/v2/releases?releasesSelector&#x3D;name(\&quot;Server\&quot;),monitoringState(\&quot;Active\&quot;),healthState(\&quot;HEALTHY\&quot;),releasesVersion(\&quot;1.0.7\&quot;).  The special characters ~ and \&quot; need to be escaped using a ~ (e.g. double quote search entityName(\&quot;~\&quot;\&quot;).
func (r ApiGetReleasesRequest) ReleasesSelector(releasesSelector string) ApiGetReleasesRequest {
	r.releasesSelector = &releasesSelector
	return r
}

// Specifies the field that is used for sorting the releases list. The field has a sign prefix (+/-) which corresponds to the sorting order (&#39;+&#39; for ascending and &#39;-&#39; for descending). If no sign prefix is set, then the default ascending sorting order will be applied. You can sort by the following properties: * &#39;product&#39;: Product name * &#39;name&#39;: Release name * &#39;stage&#39;: Stage name * &#39;version&#39;: Version * &#39;instances&#39;: Instances * &#39;traffic&#39;: Traffic  If not set, the ascending order sorting for name is applied.
func (r ApiGetReleasesRequest) Sort(sort string) ApiGetReleasesRequest {
	r.sort = &sort
	return r
}

func (r ApiGetReleasesRequest) Execute() (*Releases, *http.Response, error) {
	return r.ApiService.GetReleasesExecute(r)
}

/*
GetReleases Returns all releases

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReleasesRequest
*/
func (a *ReleasesAPIService) GetReleases(ctx context.Context) ApiGetReleasesRequest {
	return ApiGetReleasesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Releases
func (a *ReleasesAPIService) GetReleasesExecute(r ApiGetReleasesRequest) (*Releases, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Releases
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReleasesAPIService.GetReleases")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/releases"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.from != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from", r.from, "")
	}
	if r.to != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "to", r.to, "")
	}
	if r.nextPageKey != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nextPageKey", r.nextPageKey, "")
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pageSize", r.pageSize, "")
	}
	if r.demo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "demo", r.demo, "")
	}
	if r.releasesSelector != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "releasesSelector", r.releasesSelector, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
