/*
Dynatrace Environment API

 Documentation of the Dynatrace Environment API v2. Resources here generally supersede those in v1. Migration of resources from v1 is in progress.   If you miss a resource, consider using the Dynatrace Environment API v1. To read about use cases and examples, see [Dynatrace Documentation](https://dt-url.net/2u23k1k) .  Notes about compatibility: * Operations marked as early adopter or preview may be changed in non-compatible ways, although we try to avoid this. * We may add new enum constants without incrementing the API version; thus, clients need to handle unknown enum constants gracefully.

API version: 2.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package environmentv2

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ActiveGatesAPIService ActiveGatesAPI service
type ActiveGatesAPIService service

type ApiGetAllActiveGatesRequest struct {
	ctx context.Context
	ApiService *ActiveGatesAPIService
	hostname *string
	osType *string
	networkAddress *string
	loadBalancerAddress *string
	type_ *string
	networkZone *string
	updateStatus *string
	versionCompareType *string
	version *string
	autoUpdate *string
	group *string
	online *bool
	enabledModule *[]string
	disabledModule *[]string
	containerized *bool
	tokenState *string
	tokenExpirationSet *bool
}

// Filters the resulting set of ActiveGates by the name of the host it&#39;s running on.    You can specify a partial name. In that case, the &#x60;CONTAINS&#x60; operator is used.
func (r ApiGetAllActiveGatesRequest) Hostname(hostname string) ApiGetAllActiveGatesRequest {
	r.hostname = &hostname
	return r
}

// Filters the resulting set of ActiveGates by the OS type of the host it&#39;s running on.
func (r ApiGetAllActiveGatesRequest) OsType(osType string) ApiGetAllActiveGatesRequest {
	r.osType = &osType
	return r
}

// Filters the resulting set of ActiveGates by the network address.    You can specify a partial address. In that case, the &#x60;CONTAINS&#x60; operator is used.
func (r ApiGetAllActiveGatesRequest) NetworkAddress(networkAddress string) ApiGetAllActiveGatesRequest {
	r.networkAddress = &networkAddress
	return r
}

// Filters the resulting set of ActiveGates by the Load Balancer address.    You can specify a partial address. In that case, the &#x60;CONTAINS&#x60; operator is used.
func (r ApiGetAllActiveGatesRequest) LoadBalancerAddress(loadBalancerAddress string) ApiGetAllActiveGatesRequest {
	r.loadBalancerAddress = &loadBalancerAddress
	return r
}

// Filters the resulting set of ActiveGates by the ActiveGate type.
func (r ApiGetAllActiveGatesRequest) Type_(type_ string) ApiGetAllActiveGatesRequest {
	r.type_ = &type_
	return r
}

// Filters the resulting set of ActiveGates by the network zone.    You can specify a partial name. In that case, the &#x60;CONTAINS&#x60; operator is used.
func (r ApiGetAllActiveGatesRequest) NetworkZone(networkZone string) ApiGetAllActiveGatesRequest {
	r.networkZone = &networkZone
	return r
}

// Filters the resulting set of ActiveGates by the auto-update status.
func (r ApiGetAllActiveGatesRequest) UpdateStatus(updateStatus string) ApiGetAllActiveGatesRequest {
	r.updateStatus = &updateStatus
	return r
}

// Filters the resulting set of ActiveGates by the specified version.    Specify the comparison operator here.
func (r ApiGetAllActiveGatesRequest) VersionCompareType(versionCompareType string) ApiGetAllActiveGatesRequest {
	r.versionCompareType = &versionCompareType
	return r
}

// Filters the resulting set of ActiveGates by the specified version.    Specify the version in &#x60;&lt;major&gt;.&lt;minor&gt;.&lt;revision&gt;&#x60; format (for example, &#x60;1.195.0&#x60;) here.
func (r ApiGetAllActiveGatesRequest) Version(version string) ApiGetAllActiveGatesRequest {
	r.version = &version
	return r
}

// Filters the resulting set of ActiveGates by the actual state of auto-update.
func (r ApiGetAllActiveGatesRequest) AutoUpdate(autoUpdate string) ApiGetAllActiveGatesRequest {
	r.autoUpdate = &autoUpdate
	return r
}

// Filters the resulting set of ActiveGates by the group.    You can specify a partial name. In that case, the &#x60;CONTAINS&#x60; operator is used.
func (r ApiGetAllActiveGatesRequest) Group(group string) ApiGetAllActiveGatesRequest {
	r.group = &group
	return r
}

// Filters the resulting set of ActiveGates by the communication status.
func (r ApiGetAllActiveGatesRequest) Online(online bool) ApiGetAllActiveGatesRequest {
	r.online = &online
	return r
}

// Filters the resulting set of ActiveGates by the enabled modules.
func (r ApiGetAllActiveGatesRequest) EnabledModule(enabledModule []string) ApiGetAllActiveGatesRequest {
	r.enabledModule = &enabledModule
	return r
}

// Filters the resulting set of ActiveGates by the disabled modules.
func (r ApiGetAllActiveGatesRequest) DisabledModule(disabledModule []string) ApiGetAllActiveGatesRequest {
	r.disabledModule = &disabledModule
	return r
}

// Filters the resulting set of ActiveGates to those which are running in container (&#x60;true&#x60;) or not (&#x60;false&#x60;).
func (r ApiGetAllActiveGatesRequest) Containerized(containerized bool) ApiGetAllActiveGatesRequest {
	r.containerized = &containerized
	return r
}

// Filters the resulting set of ActiveGates to those with authorization token in specified state.
func (r ApiGetAllActiveGatesRequest) TokenState(tokenState string) ApiGetAllActiveGatesRequest {
	r.tokenState = &tokenState
	return r
}

// Filters the resulting set of ActiveGates to those with set expiration date for authorization token.
func (r ApiGetAllActiveGatesRequest) TokenExpirationSet(tokenExpirationSet bool) ApiGetAllActiveGatesRequest {
	r.tokenExpirationSet = &tokenExpirationSet
	return r
}

func (r ApiGetAllActiveGatesRequest) Execute() (*ActiveGateList, *http.Response, error) {
	return r.ApiService.GetAllActiveGatesExecute(r)
}

/*
GetAllActiveGates Lists all available ActiveGates

The response includes all ActiveGates that are currently connected to the environment or have been connected during last 2 hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllActiveGatesRequest
*/
func (a *ActiveGatesAPIService) GetAllActiveGates(ctx context.Context) ApiGetAllActiveGatesRequest {
	return ApiGetAllActiveGatesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ActiveGateList
func (a *ActiveGatesAPIService) GetAllActiveGatesExecute(r ApiGetAllActiveGatesRequest) (*ActiveGateList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActiveGateList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveGatesAPIService.GetAllActiveGates")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activeGates"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hostname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostname", r.hostname, "")
	}
	if r.osType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "osType", r.osType, "")
	}
	if r.networkAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkAddress", r.networkAddress, "")
	}
	if r.loadBalancerAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loadBalancerAddress", r.loadBalancerAddress, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.networkZone != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "networkZone", r.networkZone, "")
	}
	if r.updateStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updateStatus", r.updateStatus, "")
	}
	if r.versionCompareType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "versionCompareType", r.versionCompareType, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.autoUpdate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "autoUpdate", r.autoUpdate, "")
	}
	if r.group != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "group", r.group, "")
	}
	if r.online != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "online", r.online, "")
	}
	if r.enabledModule != nil {
		t := *r.enabledModule
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enabledModule", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enabledModule", t, "multi")
		}
	}
	if r.disabledModule != nil {
		t := *r.disabledModule
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "disabledModule", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "disabledModule", t, "multi")
		}
	}
	if r.containerized != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "containerized", r.containerized, "")
	}
	if r.tokenState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tokenState", r.tokenState, "")
	}
	if r.tokenExpirationSet != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tokenExpirationSet", r.tokenExpirationSet, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOneActiveGateByIdRequest struct {
	ctx context.Context
	ApiService *ActiveGatesAPIService
	agId string
}

func (r ApiGetOneActiveGateByIdRequest) Execute() (*ActiveGate, *http.Response, error) {
	return r.ApiService.GetOneActiveGateByIdExecute(r)
}

/*
GetOneActiveGateById Gets the details of the specified ActiveGate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param agId The ID of the required ActiveGate.
 @return ApiGetOneActiveGateByIdRequest
*/
func (a *ActiveGatesAPIService) GetOneActiveGateById(ctx context.Context, agId string) ApiGetOneActiveGateByIdRequest {
	return ApiGetOneActiveGateByIdRequest{
		ApiService: a,
		ctx: ctx,
		agId: agId,
	}
}

// Execute executes the request
//  @return ActiveGate
func (a *ActiveGatesAPIService) GetOneActiveGateByIdExecute(r ApiGetOneActiveGateByIdRequest) (*ActiveGate, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActiveGate
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ActiveGatesAPIService.GetOneActiveGateById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/activeGates/{agId}"
	localVarPath = strings.Replace(localVarPath, "{"+"agId"+"}", url.PathEscape(parameterValueToString(r.agId, "agId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=utf-8"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["Api-Token"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ErrorEnvelope
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
